# 13장 동시성

| 객체는 처리의 추상화다. 스레드는 일정의 추상화다. -제임스 O 코플리엔

- 동시성과 깜끔한 코드는 양립하기 어렵다.

- 깊숙한 곳에 문제가 있는 다중 스레드 코드는 짜기 쉽다. 시스템 부하 전까지 멀쩡하게 돌아간다.

- 이번장에서는 여러 스레드를 동시에 돌리는 이유, 여러 스레드를 동시에 돌리는 어려움, 이 어려움을 대처하고 깨끗한 코드를 작성하는 방법, 동시성을 테스트 하는 방법과 문제점을 논한다.

- 동시성은 책한권의 복잡한 주제다. 이 장에서는 동시성이 무엇인지 간략히만 조감한다.

> 일단 내용 시작에 앞서서 동시성이 뭔지를 좀 찾아봤다. 동시성이란 컴퓨터 시스템에서 여러 작업을 마치 동시에 실행하는것 처럼 "보이는것"을 의미한다.

> 바로 멀티태스킹과 해깔린다. 동시성과 멀티테스킹은 다른것이다. 동시성은 멀티스레드를 위한 개념이라고 생각한다. 이를 시작으로 멀티태스킹, 멀티스레드, 멀티프로세싱의 흐름에대해서 먼저 알아봤다. 관련 내용은 기존 운영체제 시간의 공부기억과 https://www.youtube.com/watch?v=QmtYKZC0lMU 이 유튜브 영상을 참고해서 알아봤다.

> 1개의 CPU가 1개의 코어를 가지고 있던 옛날. 하나의 코어에서는 한가지 작업만 할 수 있었따. 하나의 프로세스를 처리하고 다음 프로세스를 처리하고 말이다. 이를

## 동시성이 필요한 이유?

- 동시성은 결합을 없애는 전략이다. "무엇"과 "언제"를 분리하는 전략이다.

> 멀티스레드가 cpu에 할당되는 모습을 보면 각 스레드작업들이 어떤 순서로 들어가도 상관 없어야 한다. 만일 각 스레드의 실행순서, 시간등이 연결되어있다면 스레드 분리가 안될것이다.

- 단일스레드는 무엇과 언제가 밀접하다. 그래서 호출 스택을 살펴보면 프로그램 상태가 곧바로 드러난다.

- 무엇과 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다. 구조적인 관점으로 프로그램은 하나의 커다란 루프가 아니라 작은 협력프로그램 여럿이다. 그래서 이해하고 분리하기 쉽다.

> 하나의 커다란 절차적 프로그램이 아닌 컴포넌트, 메서드 등의 작은 단위의 조합으로 이루어지기 떄문에 분리하기 쉽다고 이해했다.

- 서블릿 모델은 웹 혹은 EJB컨네이터에서 돌아가는데, 이 컨테이너는 동시성을 부분적으로 관리한다. 비동기로 실행한다. 서블릿 프로그래머는 들어오는 모든 요청을 관리할 필요없다. 각 서블릿은 자신만의 세상에서 돌아간다.

> 서블릿 컨테이너가 비동기와 관련된 처리를 프로그래머가 신경쓰지 않도록 처리해준다고 이해했다.

- 그런데 동시성이 이렇게 간단하지 않다. 서블릿 컨테이너가 제공하는 경합분리 적략도 완벽과 거리가 멀다.

- 프로그래머는 동시성을 정확히 구현하도록 각별한 주의와 노력을 기울여야 한다.

> 내가 평소에도 사용하는 백엔드도 모든요청은 프레임워크 레벨에서 라우팅되고 각 요청들이 들어오는 시간대로 동기적으로 실행하지는 않는다. 비동기 적으로 요청-응답 사이클이 해결되고 있다. 개발자로서 나는 각 요청 하나하나의 흐름에 집중하면 되지 요청마다의 실행순서, 메모리 할당등에 신경쓰지 않는다.

> 그럼에도 동시성이 일어나는 프로그램을 사용할 일은 있고 이부분을 정확히 알고 있어야 한다고 이야기 한다.

- 동시성 예시들

1. 매일 수 많은 웹사이트 정보를 수집하는 수집기(응답시간과 처리량 개선)

- 수집기가 단일스레드라면 1사이트, 2사이트.. 순서대로 조회하며 넘어간다. 단일 스레드 수집기는 I/O 처리 시간이 아주 많다. 다중스레드 알고리짐은 성능을 높일 수 있다.

> 단일 스레드 작업에서 CPU는 입출력 작업이 시작되면 해당 프로세스 작업을 잠시 멈출 꺼다. 만일 멀티스레드라면 1스레드의 작업이 입출력으로 잠시멈춘동안 2스레드의 작업들이 해당 cpu리소스를 더 많이 사용할 꺼다. io작업이 많을 수록 해당 프로그램은 멀티스레드가 효율적일것 이다.

2. 한번에 한 사용자를 처리하는 시스템

   > 위 내용과 같기에 패스했다.

3. 정보를 대량으로 분석하는 시스템

- 정보를 나눠 여러 컴퓨터에서 병렬로 처리한다면 처리가 클수록 효율적일 시스템이 될것이다.

### 미신과 오해

- 동시은 어렵다. 각별이 주의해야한다. 아래는 동시성에 대한 미신과 오해다.

- 동시성은 항상 성능을 높여준다 X
  -> 동시성은 떄로 성능을 높여주는것이다. 여러 프로세서가 동시에 처리할 계산이 충분히 많은 경우에만 성능이 높아진다.

- 동시성을 구현해도 설계는 변하지 않는다. X
  -> 다중스레드 시스템은 단일 스레드 시스템과 설계가 판이하게 다르다. 무엇과 언제를 분리하면 구조가 크게 달라진다.

- 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다 X
  -> 컨테이너가 어떻게 동작하는지, 어떻게 동시 수정, 데드락을 피하는지 알아야 한다.

> 이 부분은 프레임워크에서 동시성을 구현하기 위해 어떤 작업들을 하는지 알아야한다고 말하는것 같다. nodejs 같은 단일 스레드도 비동기 처리를 위해 어떤 작업들이 일어나는지 명확이 이해해야 하는것 처럼 말이다. 나는 멀티스레드 처리와 비교해 아직 이부분을 비교해 설명할 정도가 아니라고 스스로 느낀다.

- 반대로 타당한 생각들이다.

- 동시성은 다소 부하를 유발한다 O
  -> 성능적으로 부하가 걸리며, 코드도 더 짜야한다.

- 동시성은 복잡하다. O
  -> 간단한 문제도 동시성을 복잡하다.

- 일반적으로 동시성 버그는 제현하기 어렵다. O
  -> 그래서 진짜 결함으로 간주되지 않고, 일회성 문제로 여겨 무시하기 쉽다.

> 뒤에서도 나오지만 이 일회성 문제를 넘기지 말고 철저하게 처리하라고 말한다.

- 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다. O

## 난관

- 동시성을 구현하기 어려운 이유는 아래를 보자

```java
public class X {
  private int lastIdUsed;

  public int getNextId(){
    return ++lastIdUsed;
  }
}
```

- 인스턴스 X에 lastIdUsed를 42로 설정하고 2개의 스레드가 해당 인스턴스를 공유한다. 두 스레드가 getNextId를 호출한다고 보자

1. 1스레드는 42를 읽음, 1올림, 43를 저장, 2스레드가 43을 읽음, 1올림, 44를 저장
2. 1스레드가 42를 읽음 1올림, 2스레드가 1올라간 43을 읽음, 1올림 44를 저장, 43을 저장
3. 1스레드가 42를 읽음, 2스레드도 42를 읽음, 둘다 1씩 올려서 43이됨 , 43을 저장, 43을 저장

- 위처럼 경로들이 잘못된 결과를 내놓는다.

> 데이터베이스의 트랜젝션이 되있지 않는 상황의 오손읽기와 같은 상황들이다.

## 동시성 방어 원칙

- 동시성코드의 문제로 부터 시스템을 방어하는 원칙들

> 단일 책임 원칙, 자료 범위를 제한, 자료 사본을 사용, 스레드는 가능한 독립적으로 구현

### 단일 책임 원칙

- SRP는 주어진 메서드, 클래스, 컴포넌트를 변경해야할 이유가 하나여야 한다는 원칙.

- 동시성은 복잡성 하나만으로 따로 분리할 이유가 된다. 즉 동시성코드는 다른 코드와 분리해야 한다.

- 동시성을 구현할때는 다음을 고려한다.

1. 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다.
2. 동시성 코드에는 독자적인 난관이 있다. 다른 코드의 난관과 다르며 훨씬 어렵다.
3. 잘못 구현한 동시성 코드는 별의별 방식으로 실패한다. 동시성 하나만으로 충분히 어렵다.

#### 권장사항

- 동시성 코드는 다른코드와 분리해라.

### 따름 정리(corollary): 자료 범위를 제한하라.

- 앞서 봤듯이 공유필드를 동시에 수정하다가 문제가 생겼다. 이 해결방안으로 공유객체를 사용하는 코드내 임계영역(critical section)을 synchronized 키워드로 보호하라고 권장한다.

> synchronized 키워드는 멀티스레드에서 한 객체를 동시에 접근할수 없도록 보호하는 키워드다. node에서는 어떤게 있을지 찾아봤다. 싱글스레드 기반인 js는 이런 키워드가 없지만 뮤텍스(Mutex)를 구현하는 방식으로 비슷한 효과를 볼수 있다고 한다.

- 임계영역의 수를 줄이는 기술이 중요하다. 임계영역이 많으면 보호를 빼먹는 실수, 올바로 보호했는지 계속 확인하는 노력, 버그를 찾기 어려움 등의 문제가 생긴다.

#### 권장사항

- 자료를 캡슐화 하고, 공유자료를 최대한 줄여라

### 따름 정리(corollary): 자료 사본을 사용하라

- 공유자료 줄이기 -> 처음부터 공유하지 않기, 객체를 복사해 읽기 전용으로 사용하는 방법이 가능하다.

- 객체를 복사하는 시간과 부하등 복사비용과, 동기화를 피했을때 내부잠금을 없애 절약한 수행시간등 어떤겉이 이득일지 실측해보자.

### 따름 정리(corollary): 스레드는 가능한 독립적으로 구현하라.

- 자신만의 세상에 존재하는 스레드를 구현한다. 다른 스레드와 자료를 공유하지 않는다.

- 클라이언트 요청을 처리하며 모든 정보는 비공유 출저에서 가져와 로컬 변수에 저장한다.

> 요청-응답 흐름에서 공유자원(공유 객체)를 쓰지말고 로컬 변수를 써라.

- 물론 대다수 애플리케이션은 결국 디비 같은 자원을 공유하는 상황에 처한다.

#### 권장사항

- 독자적인 스레드로, 가능하면 다른 프로세서에서, 돌려도 괜찮도록 자룔를 독립적인 단위로 분할하라.

## 라이브러리를 이해하라

> 이 부분은 자바5의 스레드 코드 구현에 대해서 고려할 사항을 이야기 하고 있다. 내 낮은 자바 이해도에 낮은 버전의 자바에 대한 내용이기 때문이 이부분은 잠시 스킵했다.

#### 권장하상

- 언어가 (동시성을 위해)제공하는 클래스를 검토하라.

## 실행 모델을 이해하라

> 스레드가 어떻게 실행되는지 이해해보자

- 먼저 몇가지 기본용어부터 이해하자

1. 한정된 자원(Bound Resource): 다중 스레드 환경에서 사용하는 자원. 크기나 숫자가 제한적이다. 데이터베이스 연결, 길이가 일정한 읽/쓰기 버퍼 등

2. 상호 배제 (Mutual Exclusion): 한 번에 한 스레드만 사용할 수 있는 공유자원, 공유자료의 경우다.

3. 기아 (Starvation): 한 스레드가 자원을 너무 오래 기다린다. 짧은 스레드에게만 우선순위를 주는경우 긴 스레드가 기아상태가 될 수 있다.

4. 데드락 (Deadlock): 여러 스레드가 서로 가진 자원을 기다리느라 모두 멈춘다. 두 스레드가 각각 필요한 자원을 하나씩 들고 기다리면 데드락에 걸린다.

5. 라이브락 (Livelock): 락을 거는 단계에서 각 스레드가 서로를 방해한다. 서로 진행과 양보를 계속 하면서 결과적으로 데드락 비슷하게 진행이 멈춘다. 아예 멈추는건 아니고.

- 기본개념을 봤으니, 다중 스레드 프로그래밍에서 사용하는 실행모델을 보자.

> 생산자-소비자, 읽기-쓰기

### 생산자-소비자

- 생산자 스레드가 정보를 생산에 버퍼, 큐에 넣는다

- 소비자 스레드가 대기열(버퍼, 큐)애서 정보를 가져와 사용한다.

- 대기열은 한정된 자원(Bound Resource) 이다.

- 생산자는 대기열이 꽉차면 멈춰야 하고 소비자는 대기열이 비어있으면 멈춰야한다. 그래서 서로에게 시그널을 보내 대기열 상태를 파악한다.

- 만일 시그널에 문제가 생기면 서로 시그널을 기다리며 멈추는상황 (데드락 또는 라이브락 같은 상황)이 생길 수 있다.

> 생산자-소비자는 nodejs의 이벤트루프, 테스크큐의 작업이나 aws 각 시스템을 연결하기위한 SQS등 여러형태로 본 익숙한 모델이었다.

### 읽기-쓰기

- 하나의 공유자원을 읽기 스레드와 쓰기 스레드가 사용하는 모델이다.

- 이 경우에 처리율이 핵심이다.

- 읽기 스레드가 우선권을 쥐고, 읽기가 끝났을때만 쓰기가 공유자원을 사용하게 만들 수 있다. 이경우는 읽기가 끝나지 않으면 쓰기 스레드가 기아상태에 걸릴 수 있다.

- 쓰기 스레드가 우선권을 쥐고, 쓰기 작업동안 읽기 작업들은 멈추게 할 수 있다. 이 경우에 쓰기가 느려질 수록 읽기 스레드의 처리율이 떨어진다.

- 읽기 스레드와 쓰기 스레드의 처리율과 기아 방지를 적절히 만족시키는 균형있는 해법이 필요하다.

> 실제로 어떤 패턴으로 조절할수 있는지는 없지만, 이 모델에서 무엇을 고민해야할지 알 수 있는 내용이었다.

### 식사하는 철학자들

- 둥근 식탁의 사람들의 왼쪽에 포크가 있다. 양쪽손으로 포크를 들어야만 식사를 할 수 있을때

- 모든 사람이 동시에 왼쪽 포크를 들면 오른쪽에 포크가 없어 식사를 할 수 있는 사람이 없어진다. (데드락)

- 어떤 사람이 오래 식사를 하면 양쪽 사람들은 기아상태에 빠진다.

- 기업 애플리 케이션은 여러 프로세스가 자원을 얻으려 경쟁한다. 주의 해서 설계하지 않으면 위 내용같은 데드락, 라이브락, 처리율 저하, 효율성 저하를 겪는다.

### 권장사항

- 대다수 다중 스레드 문제는 위 범주 중 하나다.

- 각 알고리즘을 공부하고 해법을 직접 구현해보자. 그러면 실전문제에 부닥쳤을때 해결이 쉬워진다.

- 기본 알고리즘과 각 해법을 이해하라.

## 동기화하는 메서드 사이에 존재하는 의존성을 이해하라

- 동기화 하는 메서드가 여러개고, 메서드가 서로 순서나 관계가 있다면(의존성) 찾기 어려운 버그가 생긴다.

- 공유 클래스 하나에 동기화된 메서드가 여럿이라면 구현이 올바른지 다시 확인해보자.

#### 권장사항

- 공유 객체 하나에는 메서드 하나만 사용하라.

- 물론 공유 객체 하나에 여러 메서드가 필요한 상황도 생긴다. 그 떄는 3가지를 고려하자.

1. 클라이언트에서 잠금 (Client-side Locking)

- 클라1이 요청하면 다른 스레드 클라2가 접근하지 못하도록 클라1이 서버를 잠가버린다.

2. 서버에서 잠금 (Server-side Locking)

- 클라1이 요청하면 서버 자체적으로 클라2가 접근하지 못하는 로직을 실행해라.
- 안전한 메서드를 서버에서 애초에 제공

3. 연결(Adapted) 서버

- 잠금을 하는 중간 단계를 만든다. 2번 서버에서 잠금과 유사하지만, 서버를 수정하지 못할때 사용함.

## 동기화하는 부분을 작게 만들어라

- 락은 스레드를 지연시키고 부하를 가중시키지만, 임계영역은 반드시 보호해야한다.

- 따라서 임게영역 수를 최대한 줄여야한다.

- 임계영역을 줄이기 위해 하나의 거대한 임계영역을 구현하면 스레드간에 경쟁이 늘고 프로그램 성능이 떨어지니까 주의하자.

권장사항: 동기화 하는 부분을 최대한 작게 만들어라

## 올바른 종료 코드는 구현하기 어렵다

- 영구적으로 돌아가는 시스템과 잠시돌다가 깔끔하게 종료하는 시스템은 구현하는 방법이 다르다.

- 깔끔하게 종료되는 코드는 어렵다. 흔히 발생하는 문제는 데드락이다.

- 부모자식, 생산자 소비자 사이에 제대로된 종료시그널을 받지못하면 데드락이 발생한다. 이는 종종 발생하는 문제이다.

권장사항: 종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현하라. 생각보다 어렵고 오래걸리니 이미나온 알고리즘을 검토해라.

## 스레드 코드 테스트하기

- 멀티스레드 코드가 올바르다고 증명하기는 현실적으로 불가능하다. 테스트가 정확성을 보장하지 않는다.

- 하지만 테스트는 위험을 낮춰준다.

권장사항: 문제를 노출하는 테스트 케이스를 작성해라. 설정과 부하를 바꿔가며 자주 실행해 봐라. 테스트를 실패하면 원인을 따라가고, 다시돌렸더니 통과한다고 넘아가서는 안된다.

- 아래는 테스트시 고려할 몇가지 구체적인 지침이다.

1. 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라

2. 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자

3. 다중 스레드 코드를 다른 환경에 쉽게 끼워 넣을 수 있도록 유연하게 구현하라

4. 다중 스레드 코드를 설정에 맞춰 조정할 수 있게 작성하라

5. 프로세서 수보다 많은 스레드를 돌려보라

6. 다른 플랫폼(OS 등)에서 테스트해보라

7. 보조 코드(instrument)를 넣어 돌려라. 강제로 실패를 일으키는 시도를 해보라

### 말이안되는 실패는 잠정적인 스레드 문제로 취급하라

- 다중 스레드는 가끔 말도 안되는 문제를 일으킨다.

- 말도 안되는 문제가 생겼을때 단순한 하드웨어문제, 우주선 방사선 문제같은 우연한 일회성 문제로 취급하지 말아라.

- 일회성 문제를 무시하면 잘못된 코드에 코드가 쌓인다.

권장사항: 시스템 실패를 ‘일회성’이라 치부하지 마라.

### 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자

- 스레드 환경 밖에서 코드가 제대로 도는지 반드시 확인해라.

- 강조한다.

- 스레드와 POJO(단순 자바코드, 우리의 진짜 비즈니스일듯)를 분리해서 POJO를 스레드 상관없이 테스트 해라.

권장사항: 스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅하지 마라. 먼저 스레드 환경 밖에서 코드를 올바로 돌려라.

### 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라

- 다중 스레드 코드는 스레드 수 에 상관없이 실행되게 구현해라

- 스레드 수를 바꿔보고
- 실제환경 테스트환경 바꿔가며 돌려보고
- 빠르게, 느리게 실행해보고
- 반복해서 실행해 봐라

  권장사항: 다양한 설정에서 실행할 목적으로 다른 환경에 쉽게 끼워 넣을 수 있게 코드를 구현하라.

### 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라

- 적정한 스레드 개수를 파악하는건 시행착오가 필요하다.

- 다향한 설정으로 성능을 측정해라.

- 개수를 조율하는 코드도 고민해봐라

### 프로세서 수보다 많은 스레드를 돌려보라

- 스와핑때도 문제가 발생한다. 프로세서 보다 많은 스레드를 돌려서 뻬먹은 코드나 데드락을 찾아라.

> cpu 코어보다 많은 스레드를 실행하면 모든 스레드를 동시에 실행할수 없어서 코어에 스레드간 전환(스와핑)이 일어난다고 한다. 이때 버그가 더 잘 발생한다고 한다.

### 다른 플랫폼에서 돌려보라

- 다중 스레드 코드는 플랫폼에 따라 다르게 돌아간다. 코드가 돌아갈 가능성이 있는 플랫폼 전부에 테스트를 수행해야 마땅하다.

권장사항: 처음부터 그리고 자주 모든 목표 플랫폼에서 코드를 돌려라

### 코드에 보조 코드를 넣어 돌려라. 장제로 실패를 일으키게 해보라

- 스레드 오류는 찾기 어렵다. 이유는 코드가 실행되는 수천가지 경로중에 소수만 실패하기 때문이다.

- 이처럼 드물게 발생하는 오류를 찾기위해 보조코드를 추가해 실행순서를 바꿔주며 버그를 찾아본다.

- 보조코드를 추가하는 방법은 직접구현하기와 자동화가 있다.

#### 직접 구현하기

- 직접 코드에 스레드 관련 코드를 삽입해본다.

- 스레드코드와 POJO가 분리되어있다면 코드를 삽입하기 쉽다.

> 예제 코드는 자바 스레드 메서드들을 추가해 보는 예제였다.

#### 자동화

- 위 스레드 순서를 섞을 메서드를 자동으로 추가하는 도구들을 사용해본다.

- 또한 배포환경과 테스트 환경에서 자동화 도구를 사용해본다.

권장사항: 흔들기 기법을 사용해 오류를 찾아내라.

## 결론

- 다중 스레드 코드는 올바로 구현하기 어렵다.

- 다중 스레드 코드를 작성한다면 각별하게 깨끗한 코드를 짜야한다.

- SRP를 준수하자. 스레드와 POJO를 분리하자. 테스트는 철저히 스레드 하나를 테스트 하자

- 동시성 오류를 일으키는 원인을 철저히 이해하자. 공유 자원 조작, 자원풀 공유, 프로그램 깔끔하게 종료등 경계조건을 주의하자

- 사용하는 라이브러리와 기본 알고리즘을 이해하자. 어떻게 해결하는지 파악한다.

- 공유하는 정보와 공유하지 않는 정보를 재대로 이해해서 락을 줄이자.

- 클라이언트에게 공유상태 관리 책임을 넘기지 말자

- 초반에 드러나지 않는 문제를 일회성으로 치부해 무시하지 말자.

- 많은 플랫폼에서 반복 테스트 하자. 테스트 용이성은 TDD 3대 규칙을 따르면 자연히 얻어진다.

- 보조 코드를 추가하자

# 감상문

> 클린코드에서 가장 낯선 주제였던 동시성을 알아봤다. 가장 크게 배운점은 동시성을 이해하기 위해 하드웨어와 멀티스레드 환경을 이해해본 것이다. 가장 아쉬운 부분은 내 주요 환경인 nodejs의 이벤트 루프 환경과 멀티스레드 환경에서의 명확한 구분을 이해하기 못한것이다.

> 동시성이 일어나는 환경에 대한 내 지식이 얼마나 적은지 얼마나 많은 오류를 내포하고 있는지 알게 되었다. 글쓴이의 권장사항들을 다시 읽어보면서 개발환경과 동시성이 일어날 수 있는 디비, 메모리, 이벤트처리 등에서 나가 어떤 해결을 할 수 있을지 생각해봤다.
