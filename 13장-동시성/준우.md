## 13장 동시성

- 동시성과 깔끔한 코드는 양립하기 어렵다.

### 동시성이 필요한 이유?

- 동시성은 결합을 없애는 전략이다. 즉, 무엇과 언제를 분리하는 전략이다. 스레드가 하나인 프로그램은 무엇과 언제가 서로 밀접하다.

- 단일 스레드 프로그램을 디버깅하는 프로그래머는 정지점을 정한 후 어느 정지점에 걸렸는지 살펴보면서 시스템 상태를 파악한다.

- 무엇과 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다. 구조적인 관점에서 프로그램은 거대한 루프 하나가 아니라 작은 협력 프로그램 여럿으로 보인다. 따라서 시스템을 이해하기가 쉽고 문제를 분리하기도 쉽다.

- 예를 들어, 웹 애플리케이션이 표준으로 사용하는 서블릿 모델을 보면 서블릿은 웹 혹은 EJB 컨테이너라는 우산 아래서 돌아가는데, 이들 컨테이너는 동시성을 부분적으로 관리한다. 웹 요청이 들어올 때마다 웹 서버는 비동기식으로 서블릿을 실행한다. 서블릿 프로그래머는 들어오는 모든 웹 요청을 관리할 필요가 없다. 원칙적으로 각 서브릿 스레드는 다른 서블릿 스레드와 무관하게 자신만의 세상에서 돌아간다.

- 하지만 구조적 개선만을 위해 동시성을 채택하는 건 아니다. 어떤 시스템은 응답 시간과 작업 처리량 개선이라는 요구사항으로 인해 직접적인 동시성 구현이 불가피하다.

> 이번 파트에서 이야기하고 싶어하는 부분은 결국 하나의 스레드로 작업을 하는 경우에는 작업이 느려질 수밖에 없고 이와 같은 경우에는 동시성이 필요하다는 점을 이야기하고 싶었다고 생각합니다.

#### 미신과 오해

- **동시성은 항상 성능을 높여준다.** 동시성은 **때로** 성능을 높여준다. 대기 시간이 아주 길어 여러 스레드가 프로세서를 공유할 수 있거나, 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높아진다.

- **동시성을 구현해도 설계는 변하지 않는다.** 단일 스레드 시스템과 다중 스레드 시스템은 설계가 판이하게 다르다. 일반적으로 무엇과 언제를 분리하면 시스템 구조가 크게 달라진다.

- **웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.** 실제로는 컨테이너가 어떻게 동작하는지, 어떻게 동시 수정, 데드락 등과 같은 문제를 피할 수 있는지를 알아야 한다.

- **동시성은 다소 부하를 유발한다.** 성능 측면에서 부하가 걸리며, 코드도 더 짜야 한다.

- **동시성은 복잡하다.** 간단한 문제라도 동시성은 복잡하다.

- **일반적으로 동시성 버그는 재현하기 어렵다.** 그래서 진짜결함으로 간주되지 않고 일회성 문제로 여겨 무시하기 쉽다.

- **동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.**

### 난관

- 동시성을 구현하기 어려운 이유는 다음 코드를 보면 된다.

```java
public class X {
    private int lastIdUsed;

    public int getNextId() {
        return ++lastIdUsed;
    }
}
```

- 인스턴스 X를 생성하고 lastIdUsed 필드를 42로 설정한 다음, 두 스레드가 해당 인스턴스를 공유한다. 이제 두 스레드가 getNextId();를 호출한다고 가정해보자. 결과는 셋 중 하나이다.

1. 한 스레드는 43을 받는다. 다른 스레드는 44를 받는다. lastIdUsed는 44가 된다.

2. 한 스레드는 44를 받는다. 다른 스레드는 43을 받는다. lastIdUsed는 44이 된다.

3. 한 스레드는 43를 받는다. 다른 스레드는 43을 받는다. lastIdUsed는 43이 된다.

- 두 스레드가 같은 변수를 동시에 참조하면 세 번째와 같이 놀라운 결과가 발생한다. 두 스레드가 자바 코드 한 줄을 거쳐가는 경로는 수없이 많은데, 그 중에서 일부 경로가 잘못된 결과를 내놓기 때문이다.

> 이 파트를 읽고 든 생각은 결국 두 스레드가 같이 같은 값을 읽었을 때 문제가 발생한다고 생각합니다. 그래서 생각한 부분이 임계구역이 생각이 났습니다. 임계구역은 여러 스레드가 동시에 접근해서는 안 되는 코드 영역으로, 공유 자원(여기서는 lastIdUsed)을 수정하거나 읽는 부분입니다. 위 코드에서 ++lastIdUsed가 바로 임계구역입니다. 이 구역은 한 번에 한 스레드만 실행해야 올바른 결과를 보장할 수 있습니다. 그래서 이 파트에서도 이런 부분들이 구현하기가 어려운 부분이다라고 이야기해준다고 생각했습니다.

### 동시성 방어 원칙

-
