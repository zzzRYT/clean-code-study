# 11장 시스템

| “복잡성은 죽음이다. 개발자에게서 생기를 앗아가며, 테스트하기 어렵게 만든다. - Ray Ozzie (마이크로소프트 CTO)”

## 도시를 세운다면?

- 도시를 세운다면 혼자서 직접 관리할 수 있을까? 이미 세워진 도시도 한사람의 힘으로 무리다. 도시가 잘 돌아가는건 수도 관리 팀, 전력 관리팀, 치안 관리 팀 등 각 분야를 관리하는 팀이 있기 때문이다.
- 큰그림을 그리는 사람도 있고, 작은 사항에 집중하는 사람도 있다.

- 도시가 돌아가는 또다른 이유는 추상화 모듈 때문이다. 큰그림을 몰라도 개인이 관리하는 구성요소는 효율적으로 돌아간다.
- 깨끗한 코드를 구현하면 낮은 추상화 수준에서 관심사를 분리하기 쉬워진다.

- 이 장에서는 높은 추상화 수준, 즉 시스템 수준의 깨끗함을 유지하는 방법을 살펴본다.

## 시스템 제작과 시스템 사용을 분리하라

- 제작(construction)과 사용(use)은 아주 다르다.
- 건물도 지을때 모습과 완성 후 사용할때 모습이 다른것처럼 말이다.

- 소프트웨어 시스템은 준비과정（애플리케이션 객체를 제작하고 의존성을 서로 ‘연결’하는）과 （준비 과정 이후에 이어지는）런타임 로직을 분리해야한다.

  > 도시를 세운다면? 에서 말하는 관심사 분리를 이야기 한다. 객체 생성과 의존성 관리를 준비과정이라고 말하고 서비스적 로직을 런타임 로직이라고 말하는것 같다.

- 시작단계(위의 준비과정)은 모든 애플리케이션의 관심사다.
- 관심사 분리는 우리 분야의 오래되고 중요한 기법이다.
- 많은 애플리케이션이 시작단계라는 관심사를 분리하지 않더라.

```java
// 초기화 지연 기법(lazy initialization)
public Service getService() {
    if (service == null)
        service = new MyServiceImpl(...); // 모든 상황에 적당한 기본
    return service;
}
```

> 서비스객체가 없는 초기에만 객체를 생성하고 이후에는 이미 있는 객체의 리턴만 한다. 이런 형태를 초기화 지연 또는 계산 지연이라고 한다.

- 여러 장점이 있는데, 앱실행시 바로 객체를 만드는것이 아닌, 필요시 객체를 만들기 때문에 앱 실행이 빨라진다.
- 두번째는 null리턴이 없는 점이다. 객체가 없으면 항상 생성하니까

- 하지만 getService 메서드가 MyServicelmpl과 （위에서는 생략한） 생성자 인수에 명시적으로 의존한다. 런타임 로직에서 MyServicelmpl 객체를 전혀 사용하지 않더라도 의존성을 해결하지 않으면 컴파일이 안 된다.

> 조금 어려운 문장이라 내용을 풀어본다. getService메서드에서 MyServicelmpl 클래스가 사용되고있고, 생성자를 통해 인스턴스도 만들어지고 있다. -> 이걸 명시적으로 의존한다.라고 표현한다.

> 런타임 로직에서 MyServicelmpl 객체를 전혀 사용하지 않더라도 의존성을 해결하지 않으면 컴파일이 안 된다. -> getService가 사용되지 않을 수 있다. 예를들어 api 만들고 안쓰면 getService는 호출 안될꺼다. 그럼에도 getService를 컴파일러가 확인은 할것이다. 이때 getService안에 MyServicelmpl라는 식별자가 있으니 이 클래스가 존재하는지, 문제는 없는지 컴파일러는 확인을 할것이다. MyServicelmpl가 깊은 의존관계를 가질 수록 컴파일러가 모두 확인할 것이다.

> 만일 MyServicelmpl가 변경된다면 전역적인 재컴파일이 이루어진다고 한다. 이로인해 빌드가 느려질 수 있다고 한다.
> 빌드와 재컴파일이 무슨 관계일지 잘 그림이 안그려졌는데, 코드를 기계어로 바꾸는 일련의 행동이 빌드니까. 강하게 결합된 코드가 변경이 되면 빌드코드 또한 모두 변경되는거 같다. 마치 서버사이드 렌더링 웹사이트에서 데이터가 약간만 변경되도 페이지 전체를 다시 업로드 하는것처럼 말이다.

- 테스트도 문제다.
- MyServicelmpl이 무거운 객체면 getService 호출 전에 적절한 테스트 전용 객체를 할당해야 한다.
- 또한 런타임로직 + new를 사용한 생성로직이 섞였으니 null도 확인해줘야 한다.
- 작지만 단일 책임 원칙을 깨는거다.
  > 이 부분에서 이해 안되는건 "테스트 전용 객체(Test Double, Mock)"을 테스트할때 할당해줘야하는거다. 책에서는 MyServicelmpl이 무거우니까라고 설명한다.
  > Mock 자체가 생소해서 좀 찾아봤다. 위 처럼 객체가 너무 무겁거나, 아무튼 검사하기 번거로우면 Mock으로 가짜테스트용 코드를 사용해 실제로 해당 메서드가 호출되었는지를 체크한다고 한다.

### Main 분리

- 시스템 생성과 시스템 사용을 분리하는 한 방법으로 생성 관련 코드를 모두 main 또는 main이 호출하는 모듈로 옮기는거다.

- 의존성 화살표 방향을 주목하자. 모든 화살표가 main -> 애플리케이션 이다.
  > ->는 의존성 방향이다. main이 앱을 의존한다. 이러면 코드적으로 볼때, main이 앱을 사용 또는 호출하는 형태고, 앱 방향에서는 main을 호출할 일 없이 자기 로직만 있으면된다.

### 팩토리

- 때로는 객체가 생성되는 시점을 애플리케이션이 결정할 필요도 생긴다. (ex 유저가 아이템을 주문했을때 LineItem 객체 생성 필요)
- 이때는 ABSTRACT FACTORY 패턴(추상팩토리)를 사용한다.
  > 추상 팩토리가 일반 팩토리 패턴가 차이점이 있나 찾아봤는데 일반 팩토리 패턴이 단일 객체 생성이면, 추상 팩토리는 여러가지 객체를 만드는 형태라고 한다. UiFactory.createButton(), UiFactory.createCheckbox() 등
- 그러면 시점은 애플리케이션이 정하지만 생성코드는 애플리케이션이 모른다.

> 이 파트의 사진이 좀 이해하기 어려웠다.

1. main이 LineItemFactory 인터페이스를 실체화해 factoryImpl을 생성한다.
2. OrderProcessing 이 런타임 로직. LineItemFactory인터페이스를 통해 LineItem 생성을 요청한다.
   3.factoryImpl가 LineItem을 생성해서 OrderProcessing에게 준다.
3. OrderProcessing 입장에서는 LineItem객체의 복잡한 의존성 처리나 생성자 함수를 몰라도 LineItem 인스턴스가 잘 생성되었다.

> 사실 팩토리패턴을 사용하는게 그렇게 효과적인지 잘 감이 안왔다. 그냥 `new 클래스` 이걸 함수로 한번 감싼게 팩토리 패턴이니까 말이다.
> gpt 피셜로는 그저 감싸기만 한게 아니라. 이 인스턴스를 만들기 위한 복잡한 의존성을 감출 수 있고, 테스트 용이성을 올릴 수 있다고 한다.

> 아래 내가 직접 인스턴스를 생성하던 코드를 가져와서, 이 코드가 팩토리 패턴이 어울리는지 찾아봤다.

```ts
  @Get(':partId')
  async findOne(
    @Param('partId', PositiveIntPipe) partId: number,
  ): Promise<ResPartDto> {
    const part = await this.partsService.findOne(partId);
    return new ResPartDto(part);
  }
```

> 해당 코드는 컨트롤러의 매핑메서드. 그니까 api 엔드포인트 함수다.
> 나는 ResPartDto라는 응답형태를 보내기 위해 직접 인스턴스를 생성했다. 이 파트를 읽으면서 "그럼 이부분에 팩토리를 쓰라는건가?" 라는 의문이 들었다.

> 결과적으로 위 코드에 쓸 필요는 없다. 팩토리 패턴은 말그대로 "객체"를 생성할때 사용하는거다. 복잡한 의존성을 처리하고, 테스트를 쉽게하기위해서 말이다.
> 내 코드의 ResPartDto는 객체가 아니라. 이전에 이야기한 자료구조인것이다. 그래서 복잡한 의존성도 없고 테스트도 쉽다. 그래서 이런 경우에는 그냥 생성해도 무방한거다.

> 요기까지 알게 되었을때 팩토리 패턴을 어디서 써야는지 짐작이 같다. PartsService 같은 우리가 이전에 자료구조와 비교하던 진짜 객체를 생성하는 코드인거다.(직접적인 메서드로 행동을 하는 객체라고 생각한다.)
> 그리고 내 프로젝트는 아래서 이야기할 DI가 잘 구성되었기 때문에 팩토리 패턴이 굳이 필요하지 않다는것도 이해했다.

### 의존성

- 사용과 제작을 분리하는 강력한 메커니즘 하나가 의존성 주입(Dependency Injection)이다.
- 의존성 주입은 제어 역전(nversion of Control, loC)기법을 의존성 관리에 적용한 메커니즘이다.

  > IoC기법을 구현하기 위해서 DI 방식이 사용되는거다.

- IoC에서는 한 객체가 맡은 보조 책임을 새로운객체에게 전적으로 떠넘긴다.

  > 이부분 재밌던건 나는 IoC의 개념을 프레임워크의 의존성 관리 차원에서만 배웠는데, 이 문장에서는 제어역전을 객체 생성뿐 아닌 책임 분담이라면 의존성 뿐만아닌 많은것에 해당하는 개념으로 소개하는게 재미있었다.

- 넘겨받은 책임만 맡으므로 단일책임원칙을 지키게 된다.
- 대게 책임질 메커니즘으로 main루틴이나 특수 컨테이너를 사용한다

  > nestjs의 IoC컨테이너가 생각난다.

- JNDI 검색은 의존성 주입을 ‘부분적으로’ 구현한 기능이다. 객체는 디렉터리 서버에 이름을 제공하고 그 이름에 일치하는 서비스를 요청한다.
  > JNDI는 이름을 사용해서 객체를 찾을 수 있는 기능이라고 한다.

```java
DataSource ds = (DataSource) context.lookup("jdbc/MyDatabase");
```

- 호출하는 객체는 (반환되는 객체가 적절한 인터페이스를 구현하는 한) 실제로 반환되는 객체의 유형을 제어하지 않는다. 대신 호출하는 객체는 의존성을 능동적으로 해결한다.

  > JNDI는 인터페이스 기반의 설계를 가정해서 인터페이스 형식만 맞으면 실제 구현은 알필요 없다는 그 이야기다. 요기까지는 DI의 형식도 같지만 JNDI는 lookup() 메서드를 통해 능동적으로 객체를 호출한다.

- 진정한 의존성 주입은 더 나아가서 클래스가 의존성을 해결하려 시도하지 않는다. 클래스는 완전히 수동적이다.
- 대신 의존성을 주입하는 방법으로 setter메서드나 생성자인수를 제공한다.
  > 요기서 생성자인수는 자바스프링 시간에 많이본 아래 코드를 설명하는거 같다.

```java
// ServiceImpl 생성자
public ServiceImpl(Repository repo) {
    this.repo = repo;
}
```

- DI컨테이너는 요청시 필요한 객체의 인스턴스를 만들고 생성자 인수등을 사용해 의존성을 설정한다. 실제 생성되는 객체 유형은 설정파일, 특수 생성 모듈에서 코드로 명시한다.

  > 스프링의 `@Service`에노테이션이나 nest의 모듈클래스가 생각난다.

- 스프링 프레임워크는 가장 널리 알려진 자바DI컨테이너를 제공한다.

  > 참고로 책에서는 xml로 DI를 설정한다 써있지만 지금은 대부분 자바에노테이션 기반설정을 사용한다고 한다. `@Service`

- 초기화 지연(계산 지연)은 DI를 통해서도 메커니즘을 사용할 수 있다
  > DI형태에서도 팩토리호추ㄹ, 프록시 생성 방법등으로 유사한 최적화 기법을 사용한다. 그래서 처음 설명한 초기화 지연과 의존성주입은 상충하지 않는다는걸 말하는것 같다.

## 확장

- 군락, 마을은 점점 도시로 성장하고 확장한다. 처음부터 예상하고 작은 마을에 6차선 도로를 뚫는걸 정당화 할 수는 없을꺼다. 작은 마을은 6차선 도로를 반기지 않는다.
- 시스템을 처음부터 올바르게 만들 수는 없다. 대신 오늘 주어진 사용자 스토리에 맞춰 시스템을 구현해야한다. 내일은 새로운 스토리에 맞춰 조정하고 확장한다. 이것이 반복적이고 점진적인 `애자일 방식`의 핵심이다.

- TDD, 리팩토링, 깨끗한 코드는 `코드 수준`에서 시스템을 조정하고 확장하기 쉽게 만든다.

- `시스템 수준`에서는 어떨까? 단순한 아키텍처를 복잡한 아키텍처로 조금씩 키울수 없다고 말하지만, 소프트웨어 시스템은 관심사를 적절히 분리해 관리한다면 소프트웨어 아키텍처도 점직적으로 발전할 수 있다.

- 관심사를 적절히 분리하지 못하느 아키텍처의 예

```java
package com.example.banking;

import java.util.Collection;
import javax.ejb.*;

public interface BankLocal extends EJBLocalObject {
    String getStreetAddr1() throws EJBException;
    String getStreetAddr2() throws EJBException;
    String getCity() throws EJBException;
    String getState() throws EJBException;
    String getZipCode() throws EJBException;

    void setStreetAddr1(String street1) throws EJBException;
    void setStreetAddr2(String street2) throws EJBException;
    void setCity(String city) throws EJBException;
    void setState(String state) throws EJBException;
    void setZipCode(String zip) throws EJBException;

    Collection getAccounts() throws EJBException;
    void setAccounts(Collection accounts) throws EJBException;
    void addAccount(AccountDTO accountDTO) throws EJBException;
}
```

- 원래 EJB1과 EJB2 아키텍처는 관심사를 적절히 분리하지 못했기에 유기적인 성장이 어려웠다.

  > 비즈니스 로직, 데이터 접근 로직, 네트워크 등등 많은 관심사가 섞여있는 코드다. 유지보수, 확장, 테스트에 불편하다.

- 위 인터페이스를 구현한 코드

```java
package com.example.banking;

import java.util.Collection;
import java.util.Collections;
import javax.ejb.*;
import javax.naming.InitialContext;

public abstract class Bank implements javax.ejb.EntityBean {

    // 비즈니스 논리
    public abstract String getStreetAddr1();
    public abstract String getStreetAddr2();
    public abstract String getCity();
    public abstract String getState();
    public abstract String getZipCode();

    public abstract void setStreetAddr1(String street1);
    public abstract void setStreetAddr2(String street2);
    public abstract void setCity(String city);
    public abstract void setState(String state);
    public abstract void setZipCode(String zip);

    public abstract Collection getAccounts();
    public abstract void setAccounts(Collection accounts);

    public void addAccount(AccountDTO accountDTO) {
        try {
            InitialContext context = new InitialContext();
            AccountHomeLocal accountHome = (AccountHomeLocal) context.lookup("AccountHomeLocal");
            AccountLocal account = accountHome.create(accountDTO);

            Collection accounts = getAccounts();
            accounts.add(account);
        } catch (Exception e) {
            throw new EJBException("Failed to add account", e);
        }
    }

    // EJB 컨테이너 논리
    public abstract void setId(Integer id);
    public abstract Integer getId();

    public Integer ejbCreate(Integer id) throws CreateException {
        setId(id);
        return null;  // EJB 2.x에서는 create 메서드가 null 반환
    }

    public void ejbPostCreate(Integer id) {}

    public void setEntityContext(EntityContext ctx) {}
    public void unsetEntityContext() {}
    public void ejbActivate() {}
    public void ejbPassivate() {}
    public void ejbLoad() {}
    public void ejbStore() {}
    public void ejbRemove() {}
}
```

> 핵심 로직(비즈니스 로직)이 독립적이지 못하고, EJB의 컨테이너라는 구조 안에 깊게 묶여 있다고 한다.

- 클래스를 생성할 때는 컨테이너에서 파생해야 하며 컨테이너가 요구하는 다양한 생명주기 메서드도 제공해야 한다.

  > 자유롭게 클래스를 못 만들고 컨테이너의 룰을 따라야 한다.

- 이렇듯 비즈니스 논리가 덩치 큰 컨테이너와 밀접하게 결합된 탓에 독자적인 단위 테스트가 어렵다.
- 컨테이너를 흉내 내거나(쉽지 않은 일이다!) 아니면 많은 시간을 낭비하며 EJB와 테스트를 실제 서버에 배치해야 한다. 그래서 EJB2 코드는 프레임워크 밖에서 재사용하기란 사실상 불가능하다.

- 결국 객체 지향 프로그래밍이라는 개념조차 뿌리가 흔들린다.

- 빈은 빈을 상속받지 못한다. 일반적으로 DTO를 정의한다. DTO는 사실상 구조체이다. 즉 동일한 정보를 저장하는 자료유형이 2개가 된다.
  그래서 한 객체에서 다른 객체로 자료를 복사하는 반복적 코드가 필요하다.

  > 관심사 로직이 잘 나눠지지 않는 예제 설명하다가 왜 DTO와 객체지향 개념까지 이야기가 세는지 문맥흐름이 이상해서 생각해봤다. 아무튼 핵심은 EJB2가 비효율적이라는 의미에서 나온 이야기 같다.

> EJB2가 비효율적이라는건 예제가 아닌 뭔가 깔려고 하는거 같은데 EJB2가 뭔지부터 제대로 찾아 봤다.
> EJB2 란 2000년대 초반 Java EE(지금의 Jakarta EE)에서 분산 기업 애플리케이션을 만들기 위해 사용된 서버 사이드 컴포넌트 모델이라고 한다. 스프링전에 유행한 표준기술이라고 한다. 하지만 위에서 이야기한 여러가지 문제로 지금은 거의 사용되지 않는거 같다.

### 횡단（cross-cutting） 관심사

- EJB2는 일부 관심사를 잘 분리하긴 했는데 트랜잭션, 보안, 일부 영속적인 동작을 소스코드가 아니라 배치 기술사에서 정의한다.

- 영속성과 같은 관심사는 애플리케이션의 자연스러운 객체 경계를 넘나드는 경향이 있다. 전반적으로 동일한 방식을 이용하게 만들어야 한다.

> 영속성(데이터베이스나 파일에 저장되야할 영속적인 데이터 등)같은 객체마다 자연스럽게 사용하는 관심사들이 있는데 (로깅, 예외처리, 트랜젝션 등) 이런건 항상 반복되는 작업이며 다들 다르게 작성할 수 있는 부분이다. 하지만 같은 관심사들은 동일한 방식으로 작성되어야 한다고 한다.

- 원론적으로는 모듈화되고 캡슐화된 방식으로 영속성 방식을 구상할 수 있다. 하지만 현실적으로는 영속성 방식을 구현한 코드가 온갖 객체로 흩어진다. 여기서 횡단 관심사라는 용어가 나온다.

> 횡단 관심사(cross-cutting concern)란 프로그램 전반에 걸쳐 공통적으로 적용되어야 하지만, 핵심 로직과는 직접 관련 없는 기능이라고 한다.
> 위에서 표현한 인증, 로깅, 트랜젝션등이 딱 모든 흐름에서 쓰이지면서 중요하지만, 그 흐름의 핵심 비즈니스는 아닌 그런 횡단 관심사인거 같다.

- 영속성 프레임워크 또한 모듈화할 수 있다.

  > nest프로젝트에서 orm인 prisma를 적용할때 공식문서 예제를 따라가면 자연스럽게 prisma용 모듈을 만들게 된다. 영속성 프레임워크를 모듈화 한다는 글에서 이것이 생각났다.

- 도메인 논리도 (독자적으로) 모듈화할 수 있다. 문제는 이 두 영역이 세밀한 단위로 겹친다는 점이다.

  > 우리 프로젝트도 도메인 별로 모듈이 만들어졌다. 그리고 해당모듈에 트랜젝션이나 로깅등이 분리되지 않고 섞인게 생각난다. 이곳까지 읽어보니 인증을 모듈로 분리했던것처럼 해당 횡단 관심사를 모듈로 만들어갸겠다는 생각기 점점 든다.

- EJB 아키텍처가 영속성, 보안, 트랜잭션을 처리하는 방식은 관점 지향 프로그래밍(AOP)을 예견했다고 보인다. AOP는 횡단 관심사에 대처해 모듈성을 확보하는 일반적인 방법론이다.

  > AOP는 여기저기 흩어진 관심사(예: 로깅, 보안)를 하나로 모아 처리할 수 있게 해주는 방법론이라고 한다. 처음에는 횡단관심사를 모듈링 하는걸 AOP라고 하는거라고 짧게 생각했다.

- AOP에서 ‘관점(aspect)’이라는 모듈 구성 개념은 “특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 있게 바꿔야 한다. 간결한 선언이나 프로그래밍 메커니증으로 수행한다.
  > 이곳에서 AOP 관점지향 프로그래밍이 내가 생각하던 관심사의 모듈화와 뭐가 다른지 알게되었다. AOP는 관점의 분리와 함께 간결한 선언 형식의 프로그래밍을 하는거라고 생각한다. nest, 스프링등에서 제공하는 어노테이션이나 도구들이 이런 AOP를 구현하는 핵심인걸 생각했다.

```ts
  @Post()
  @RBAC(Role.admin)
  @UseInterceptors(TransectionInterceptor)
  postMovie(
    @Body() body: CreateMovieDto,
    @Request() req
  ) {
    return this.moviesService.createMovie(body, req.queryRunner);
  }
```

> 다시 컨트롤러의 매핑메서드를 가져왔다. @RBAC(Role.admin) 은 인증시스템이다. nest의 가드를 사용했다. @UseInterceptors(TransectionInter)은 트랜젝션에 관한 시스템이다. nest의 인터셉터를 사용했다. 요기서 중요한건 두 기능은 다른 형식으로도 작성, 가능하게 만들수 있다. 하지만 컨트롤러에 해당 개념이 한줄로 표현되게 선언적으로 붙였다.(관점을 표현함) 이걸로 비즈니스에 해당 기능이

## 자바 프록시

## 순수 자바 AOP 프레임워크

## AspectJ 관점

## 테스트 주도 시스템 아키텍처 구축

## 의사 결정을 최적화하라

## 명백한 가치가 있을 때 표준을 현명하게 사용하라

## 시스템은 도메인 특화 언어가 필요하다

## 결론

# 감상문
