# 11장 시스템

"복잡성은 죽음이다. 개발자에게서 생기를 앗아가며, 제품을 계획하고 제작하고 테스트하기 어렵게 만든다." - 레이 오지(Ray Ozzie), 마이크로소프트 쵝고 기술 책임자 CTO

## 도시를 세운다면?

- 이미 세워진 도시라도 한 사람의 힘으로는 무리다. 그럼에도 불구하고 도시는 각 분야를 관리하는 팀이 있기 때문에 잘 돌아간다.
- 도시가 돌아가는 또 다른 이유는 적절한 추상화와 모듈화 때문이다. 그래서 개인과 개인이 관리하는 '구성요소'는 효율적으로 돌아간다.
- 이 장에서는 높은 추상화 수준, 즉 시스템 수준에서도 깨끗함을 유지하는 방법을 살펴본다.

> 도시는 복잡하지만 역할을 나눠 관리하니 잘 돌아간다며 이걸 소프트웨어에 비유하였습니다. 쉽게 보면 모든 걸 한 파일에 몰아넣지 말고, 모듈화랑 추상화를 통해서 관리하라는 내용 같네요.

## 시스템 제작과 시스템 사용을 분리하라

- 우선 제작은 사용과 아주 다르다는 사실을 명심한다.
  - 소프트웨어 시스템은 (애플리케이션 객체를 제작하고 의존성을 서로 '연결'하는) 준비 과정과 (준비 과정 이후에 이어지는) 런타임 로직을 분리해야 한다.
- 시작 단계는 모든 애플리케이션이 풀어야 할 관심사다. 관심사 분리는 우리 분야에서 가장 오래되고 가장 중요한 설계 기법 중 하나다.

시작 단계와 실행 단계를 뒤섞은 코드

```java
public Service getService() {
  if (service == null)
    service = new MyServiceImpl(...);  // 모든 상황에 적합한 기본값일까?
  return service;
}
```

- 문제가 생기는 이유
  - 런타임 로직에서 MyServiceImpl 객체를 전혀 사용하지 않더라도 의존성을 해결하지 않으면 컴파일이 안 된다.
  - MyServiceImpl 객체가 무거운 객체라면 테스트 시 Mock 객체로 대체하기가 어렵다.
  - service가 null인 경로와 아닌 경로 등 모든 실행 경로도 테스트해 하기 때문에 작업을 두 가지 이상 수행한다. 즉, SRP를 위반한다.

### Main 분리

- 생성과 관련한 코드는 모두 main이나 main이 호출하는 모듈로 옮긴고, 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정한다.
- main 함수에서 시스템에 필요한 객체를 생성한 후 이를 애플리케이션에 넘긴다. 애플리케이션은 그저 객체를 사용할 뿐이다.
- 애플리케이션은 main이나 객체가 생성되는 과정을 전혀 모른다. 단지 모든 객체가 적절히 생성되었다고 가정한다.

### 팩토리

- 때로는 객체가 생성되는 시점을 애플리케이션이 결정할 필요도 생긴다.
- 애플리케이션은 LineItem을 만들어야 하지만 어떻게 만드는지는 몰라도 된다.
