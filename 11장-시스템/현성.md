# 11장 시스템

"복잡성은 죽음이다. 개발자에게서 생기를 앗아가며, 제품을 계획하고 제작하고 테스트하기 어렵게 만든다." - 레이 오지(Ray Ozzie), 마이크로소프트 쵝고 기술 책임자 CTO

## 도시를 세운다면?

- 이미 세워진 도시라도 한 사람의 힘으로는 무리다. 그럼에도 불구하고 도시는 각 분야를 관리하는 팀이 있기 때문에 잘 돌아간다.
- 도시가 돌아가는 또 다른 이유는 적절한 추상화와 모듈화 때문이다. 그래서 개인과 개인이 관리하는 '구성요소'는 효율적으로 돌아간다.
- 이 장에서는 높은 추상화 수준, 즉 시스템 수준에서도 깨끗함을 유지하는 방법을 살펴본다.

> 도시는 복잡하지만 역할을 나눠 관리하니 잘 돌아간다며 이걸 소프트웨어에 비유하였습니다. 쉽게 보면 모든 걸 한 파일에 몰아넣지 말고, 모듈화랑 추상화를 통해서 관리하라는 내용 같네요.

## 시스템 제작과 시스템 사용을 분리하라

- 우선 제작은 사용과 아주 다르다는 사실을 명심한다.
  - 소프트웨어 시스템은 (애플리케이션 객체를 제작하고 의존성을 서로 '연결'하는) 준비 과정과 (준비 과정 이후에 이어지는) 런타임 로직을 분리해야 한다.
- 시작 단계는 모든 애플리케이션이 풀어야 할 관심사다. 관심사 분리는 우리 분야에서 가장 오래되고 가장 중요한 설계 기법 중 하나다.

시작 단계와 실행 단계를 뒤섞은 코드

```java
public Service getService() {
  if (service == null)
    service = new MyServiceImpl(...);  // 모든 상황에 적합한 기본값일까?
  return service;
}
```

- 문제가 생기는 이유
  - 런타임 로직에서 MyServiceImpl 객체를 전혀 사용하지 않더라도 의존성을 해결하지 않으면 컴파일이 안 된다.
  - MyServiceImpl 객체가 무거운 객체라면 테스트 시 Mock 객체로 대체하기가 어렵다.
  - service가 null인 경로와 아닌 경로 등 모든 실행 경로도 테스트해 하기 때문에 작업을 두 가지 이상 수행한다. 즉, SRP를 위반한다.
