# 11장 시스템

"복잡성은 죽음이다. 개발자에게서 생기를 앗아가며, 제품을 계획하고 제작하고 테스트하기 어렵게 만든다." - 레이 오지(Ray Ozzie), 마이크로소프트 쵝고 기술 책임자 CTO

## 도시를 세운다면?

- 이미 세워진 도시라도 한 사람의 힘으로는 무리다. 그럼에도 불구하고 도시는 각 분야를 관리하는 팀이 있기 때문에 잘 돌아간다.
- 도시가 돌아가는 또 다른 이유는 적절한 추상화와 모듈화 때문이다. 그래서 개인과 개인이 관리하는 '구성요소'는 효율적으로 돌아간다.
- 이 장에서는 높은 추상화 수준, 즉 시스템 수준에서도 깨끗함을 유지하는 방법을 살펴본다.

> 도시는 복잡하지만 역할을 나눠 관리하니 잘 돌아간다며 이걸 소프트웨어에 비유하였습니다. 쉽게 보면 모든 걸 한 파일에 몰아넣지 말고, 모듈화랑 추상화를 통해서 관리하라는 내용 같네요.

## 시스템 제작과 시스템 사용을 분리하라

- 우선 제작은 사용과 아주 다르다는 사실을 명심한다.
  - 소프트웨어 시스템은 (애플리케이션 객체를 제작하고 의존성을 서로 '연결'하는) 준비 과정과 (준비 과정 이후에 이어지는) 런타임 로직을 분리해야 한다.
- 시작 단계는 모든 애플리케이션이 풀어야 할 관심사다. 관심사 분리는 우리 분야에서 가장 오래되고 가장 중요한 설계 기법 중 하나다.

시작 단계와 실행 단계를 뒤섞은 코드

```java
public Service getService() {
  if (service == null)
    service = new MyServiceImpl(...);  // 모든 상황에 적합한 기본값일까?
  return service;
}
```

- 문제가 생기는 이유
  - 런타임 로직에서 MyServiceImpl 객체를 전혀 사용하지 않더라도 의존성을 해결하지 않으면 컴파일이 안 된다.
  - MyServiceImpl 객체가 무거운 객체라면 테스트 시 Mock 객체로 대체하기가 어렵다.
  - service가 null인 경로와 아닌 경로 등 모든 실행 경로도 테스트해 하기 때문에 작업을 두 가지 이상 수행한다. 즉, SRP를 위반한다.

### Main 분리

- 생성과 관련한 코드는 모두 main이나 main이 호출하는 모듈로 옮긴고, 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정한다.
- main 함수에서 시스템에 필요한 객체를 생성한 후 이를 애플리케이션에 넘긴다. 애플리케이션은 그저 객체를 사용할 뿐이다.
- 애플리케이션은 main이나 객체가 생성되는 과정을 전혀 모른다. 단지 모든 객체가 적절히 생성되었다고 가정한다.

### 팩토리

- 때로는 객체가 생성되는 시점을 애플리케이션이 결정할 필요도 생긴다.
- 애플리케이션은 LineItem을 만들어야 하지만 어떻게 만드는지는 몰라도 된다.

> 저는 이 부분이 상당히 어렵게 느껴져서 GPT에게 비유적인 표현을 써서 알려줄 수 있겠느냐고 물어봤습니다. 아래는 GPT가 알려준 내용입니다.

역할

- main = 레스토랑 주방장
- 팩토리 (LineItemFactory) = 요리사
- OrderProcessing = 웨이터
- LineItem = 요리된 음식

흐름 요약

1. 주방장(main)이 요리사(Factory)를 고르고 준비
→ 어떤 요리사인지, 어떤 재료 쓰는지는 다 주방장이 결정.

2. 웨이터(OrderProcessing)는 요리가 필요할 때 요리사에게 "요리 만들어 주세요"라고만 말함
→ "어떻게 만드는지는 관심 없음."

3. 요리사(Factory)가 실제로 요리를 만들어서 줌

4. 웨이터는 요리를 받아 손님에게 전달

한 줄 비유 요약

"웨이터는 음식을 어떻게 만드는지 신경 안 씁니다. 요리사가 알아서 만들어주면, 웨이터는 그냥 손님에게 가져다주기만 하면 됩니다."

> 이 비유를 통해서 팩토리 패턴의 역할과 흐름을 조금이나마 이해할 수 있었습니다. 웨이터는 주문 전달만, 요리사는 요리만, 이런 식으로 서로 책임이 명확해지면서 역할 분리가 잘 된 것을 느꼈습니다.

## 확장

- '처음부터 올바르게' 시스템을 만들 수 있다는 믿음은 미신이다. 대신에 우리는 오늘 주어진 사용자 스토리에 맞춰 시스템을 구현해야 한다. 이것이 반복적이고 점진적인 애자일 방식의 핵심이다.
- 소프트웨어 시스템은 물리적인 시스템과 다르다. 관심사를 적절히 분리해 관리한다면 소프트웨어 아키텍처는 점진적으로 발전할 수 있다.

Bank EJB용 EJB2 지역 인터페이스

```java
package com.example.banking;

import java.util.Collections;
import javax.ejb.*;

public interface BankLocal extends java.ejb.EJBLocalObject {
  String getStreetAddr1() throws EJBException;
  String getStreetAddr2() throws EJBException;
  String getCity() throws EJBException;
  String getState() throws EJBException;
  String getZipCode() throws EJBException;
  void setStreetAddr1(String street1) throws EJBException;
  void setStreetAddr2(String street2) throws EJBException;
  void setCity(String city) throws EJBException;
  void setState(String state) throws EJBException;
  void setZipCode(String zip) throws EJBException;
  Collection getAccounts() throws EJBException;
  void setAccounts(Collection accounts) throws EJBException;
  void addAccount(AccountDTO accountDTO) throws EJBException;
}
```

- 열거하는 속성은 Bank 주소, 은행이 소유하는 계좌다. 각 계좌 정보는 Account EJB로 처리한다.

상응하는 EJB2 엔티티 빈 구현

```java
package com.example.banking;

import java.util.Collections;
import javax.ejb.*;

public abstract class Bank implements javax.ejb.EntityBean {
  // 비즈니스 논리...
  public abstract String getStreetAddr1();
  public abstract String getStreetAddr2();
  public abstract String getCity();
  public abstract String getState();
  public abstract String getZipCode();
  public abstract void setStreetAddr1(String street1);
  public abstract void setStreetAddr2(String street2);
  public abstract void setCity(String city);
  public abstract void setState(String state);
  public abstract void setZipCode(String zip);
  public abstract Collection getAccounts();
  public abstract void setAccounts(Collection accounts);

  public void addAccount(AccountDTO accountDTO) {
    InitialContext context = new InitialContext();
    AccountHomeLocal accountHome = context.lookup("AccountHomeLocal");
    AccountLocal account = accountHome.create(accountDTO);
    Collection accounts = getAccounts();
    accounts.add(account);
  }

  // EJB 컨테이너 논리
  public abstract void setId(Integer id);
  public abstract Integer getId();
  public Integer ejbCreate(Integer id) { ... }
  public void ejbPostCreate(Integer id) { ... }
  // 나머지도 구현해야 하지만 일반적으로 비어있다.
  public void setEntityContext(EntityContext ctx) {}
  public void unsetEntityContext() {}
  public void ejbActivate() {}
  public void ejbPassivate() {}
  public void ejbLoad() {}
  public void ejbStore() {}
  public void ejbRemove() {}
}
```

- EJB2가 실패한 이유
  - 비즈니스 로직이 컨테이너(서버 환경)에 강하게 결합되어 있어서 단위 테스트가 어렵다.
  - 여러 생명주기 메서드를 강제로 구현해야 한다.
  - 컨테이너 없이 실행하거나, 다른 곳에서 재사용할 수 없다.
  - DTO를 별도로 만들어야 하고, 이 객체에는 메서드가 없기 때문에 한 객체에서 다른 객체로 자료를 복사하는 반복적인 규격 코드가 필요하다.

### 횡단(cross-cutting) 관심사

- 영속성과 같은 관심사는 애플리케이션의 자연스러운 객체 경계를 넘나드는 경향이 있다. 모든 객체가 전반적으로 동일한 방식을 이용하게 만들어야 한다.
