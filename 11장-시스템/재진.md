# 11장 시스템

> 복잡성은 죽음이다. 개발자에게서 생기를 앗아가며, 제품을 계획하고 제작하고 테스트하기를 어렵게 만든다. - 레오 오지

## 도시를 세운다면?

도시를 혼자서 관리하기란 불가능하다. 이미 각 분야에 맞는 팀들이 있고, 각자 맡은 일을 열심히 수행하기에 도시가 돌아간다.

도시가 돌아가는 또다른 이유는, 적절한 추상화 모듈 덕분이다.
큰 그림을 이해하지 못하더라도, 개인과 개인이 관리하는 "구성요소"는 효율적으로 돌아간다.

흔히 소프트웨어 팀도 도서처럼 구성한다. 하지만 막상 각 팀이 제작하는 시스템은 비슷한 수준으로 추상화하거나 분리하지 못하는 경우가 많다.

깨끗한 코드를 구현하려면, 낮은 수준의 수준의 추상화 수준에서 관심사를 분리하기 쉬워진다.

> 위 내용에서 말하는 "구성요소"가 무엇일까? 하는 생각을 했습니다.

위에서 언급한 내용을 좀 살펴보면, 수도팀, 전력팀.. 등등 여러 팀으로 나눠져 있다고 언급합니다. 소프트웨어 팀도 마찬가지라고 하는데, 아마 서비스를 만드는데 있는 구성요소 즉, 도메인을 이야기하는게 아닐까?라는 생각을 했습니다. 이 부분에서 마치 `모노레포`와 유사하다고 느꼈습니다. 모노레포는 각 폴더별로 다른 도메인과 각각의 책임을 가집니다. 실제론 거대한 하나의 서비스를 만드는 팀을 세분화 시켜서 작업을 하지만, 각각의 팀은 각각의 `모노레포`에 책임만을 가지고 있습니다.

## 시스템 제작과 시스템 사용을 분리하라

시스템 제작과 사용은 다르다. 새롭게 호텔 건물이 지어지고 있다, 현재는 안전모와 작업복, 거중기 승강기를 부착해 놓은 형태이지만, 1년 뒤에는 예쁜 유리벽과, 깔끔한 색상으로 바뀌고, 사람들도 다른 차림으로 변할 것이다.

> 소프트웨어 시스템은 (어플리케이션 객체를 제작하고 의존성을서로 '연결'하는) 준비 과정과 (준비 과정 이후에 이어지는) 런타임 로직을 분리해야 한다.

우리가 처음 살펴볼 부분은 관심사이다. 관심사 분리는 중요한 설계 기법 중 하나다.

```java
public Service getService() {
  if (service == null) {
    service = new MyServiceImpl( ... );
  }
  return service;
}
```

실제로 필요할 때 까지 객체를 생성하지 않으므로 불필요한 부하가 걸리지 않아 유용해 보인다.

하지만 `getService`메서드는 `MyServiceImpl`에 의존한다. 런타임에서는 `MyServiceImpl`를 전혀 사용하지 않더라도, 의존성 문제를 해결하지 않으면 컴파일이 안된다.

테스트도 문제다. `MyServiceImpl`가 무거운 객체라면, 테스트 전용객체나 service필드에 할당해야한다, 또 한 일반 런타임 로직에다 객체를 섞어놨기 때문에, null인 경로와 아닌 경로에 대한 테스트를 모두 작성해야 한다.

- 위 문제는 SRP를 깬다는 말을 의미한다.

해당 부분의 로직을 한 번 정도 사용한다는 것은 문제가 아닐 수 있다. 하지만 여러 부분에서 이런 기법을 곳곳해서 사용한다면 모듈성을 떨어지고. 중복이 심해진다.

체계적이고 탄탄한 시스템을 만들고 싶다면, 손쉬운 기법으로 모듈성을 깨서는 안된다.

### Main 분리

시스템 생성과 사용을 분리하는 한 가지 방법으로, 생상한 코드 모두 main이나 main이 호출하는 모듈로 옮기고, 나머지 시스템은 모든객체가 생성되었고 모든 의존성이 연결되었다고 가정한다.

main함수에서 시스템에 필요한 객체를 생성한 후 애플리케이션에 넘긴다. 애플리케이션은 그저 객체를 사용할 뿐이다.

> 위에서 한 번 언급된 코드를 가지고 main에서 의존성을 주입하는 방식으로 바꿔봤습니다.

```javascript
// Service 인터페이스처럼 사용할 클래스
class MyService {
  execute() {
    console.log("서비스 실행!");
  }
}

// App 클래스 (서비스를 외부에서 주입받음)
class App {
  constructor(service) {
    this.service = service;
  }

  getService() {
    return this.service;
  }
}

// main 역할
function main() {
  const service = new MyService(); // 직접 생성
  const app = new App(service); // 의존성 주입
  const s = app.getService();
  s.execute();
}

main();
```

메서드 내부에서 객체를 선언하는 방식이 아닌, main에서 선언을하고, 의존성으로 주입하는 형식입니다.

### 팩토리

때로는 객체가 생성되는 시점을 애플리케이션(각 메서드)가 결정해야할 필요도 생긴다. 이럴 때 ABSTRACT FACTORY 패턴을 사용할 수 있다.

이 부분도 어려워서, 코드로 대체

```javascript
class MyService {
  constructor(message) {
    this.message = message;
  }

  execute() {
    console.log(this.message);
  }
}

// 팩토리: 어떻게 생성할지는 이 객체가 책임
class MyServiceFactory {
  createService(message) {
    return new MyService(message);
  }
}

// 애플리케이션: 생성 시점은 내가 결정, 하지만 생성 방식은 몰라
class App {
  constructor(factory) {
    this.factory = factory;
  }

  onUserAction(msg) {
    const service = this.factory.createService(msg); // 이 순간에 생성!
    service.execute();
  }
}

// main: 앱과 팩토리 설정
function main() {
  const factory = new MyServiceFactory();
  const app = new App(factory);

  // 사용자가 어떤 버튼을 눌렀다고 가정
  app.onUserAction("안녕!");
  app.onUserAction("다시 실행!");
}

main();
```

팩토리얼 패턴 같은 경우에는, 메서드 내부 즉, 어플리케이션 내부에서 객체 생성 여부를판단해야 하는 경우에 사용합니다. 그래서 factory라는 클래스를 통해서 오로지 팩토리를 생성시키는 역할을 부여하고, 팩토리를 통해서 서비스를 생성시킵니다. 그렇게 생성된 서비스를 App에 주입시켜서 생성되는 시점을 결정할 수 있습니다.

### 의존성 주입

사용자의 제작을 분리하는 강력한 메커니즘 하나가 `의존성 주입`이다.

의존성 관리 맥락에서 객체는 의존성 자체를 인스턴스로 만드는 책임을 지지 않는다. 대신 이런 책임을 다른 '전담'메커니즘에 넘겨야 한다.

'책임질' 메커니즘으로 `main`루틴이나, `container`를 사용한다.

```java
MyService myService = (MyService)(jndiContext.lookup("NameOfMyService"));
```

호출하는 객체는 실제로 반환되는 객체의 유형을 제어하지 않는다. 대신 호출하는 객체는 의존성을 능동적으로 해결한다.

진정한 의존성 주입은 여기서 한 걸음 더 나간다.

클래스가 의존성을 해결하려 시도하지 않는다. 클래스는 완전히 수동적이다. 대신 의존성을 주입하는 방법으로 설정자 메서드나 생성자 인수를 제공한다.

DI(의존성 주입)컨테이너는 필요한 객체의 인스턴스를 만든 후 생성자 인수나 설정자 메서드를 사용해 의존성을 설정한다.

> 이 부분은 어려워서 개인적으로 react 쪽으로 설명하겠습니다.

react에서는 HOC(고차컴포넌트)개념이 존재합니다. 위에서 계속 설명했던, 의존성과 재활용성을 강조한 전략인데, 다음과 같은 상황에서 사용합니다.

```jsx
function UserList() {
  const users = fetchUsers();
  return (
    <div>
      {users.map((user) => (
        <p>{user.name}</p>
      ))}
    </div>
  );
}
```

fetchUsers를 통해서 서버로부터 받아온 데이터를 list형태로 뿌려주는 컴포넌트입니다.

여기서 UserList의 의존성은 fetchUsers입니다.
fetchUser에서 받아온 값을 통해서 해당 리스트를 뿌려주기 때문이죠.

이 부분을 단순하게, 메서드형태로 받아서 의존성을 주입받을 수 있습니다.

```jsx
function UserList({ fetchUsers }) {
  const users = fetchUsers();
  return (
    <div>
      {users.map((user) => (
        <p>{user.name}</p>
      ))}
    </div>
  );
}

// 사용 시 외부에서 주입
<UserList fetchUsers={myFetchUsersFn} />;
```

하지만 이렇게 한다면, 매번 fetchUsers에 대한 값을 사용하는 부분에서 정의해야 하기 때문에 중복된 코드가 발생할 수 있습니다.

이 때 사용하는게 HOC(고차 컴포넌트) 입니다.

```jsx
// withFetchUsers.tsx
import React, { useEffect, useState } from 'react';

type User = { id: number; name: string };

function withFetchUsers<P>(
  WrappedComponent: React.ComponentType<P & { users: User[] }>
) {
  return function WithFetchUsersComponent(props: P) {
    const [users, setUsers] = useState<User[]>([]);

    useEffect(() => {
      const fetchUsers = async () => {
        await new Promise(resolve => setTimeout(resolve, 1000));
        setUsers([
          { id: 1, name: 'Alice' },
          { id: 2, name: 'Bob' },
        ]);
      };

      fetchUsers();
    }, []);

    return <WrappedComponent {...props} users={users} />;
  };
}

export default withFetchUsers;


```

다음과 같이 사용할 수 있습니다. 대충 DI container라고 이해하시면 됩니다. 여기서 fetch를 통해서 서버로부터 데이터를 받아오는 것이죠,

```jsx
// UserList.tsx
import withFetchUsers from "./withFetchUsers";
type User = { id: number, name: string };

function UserList({ users }: { users: User[] }) {
  return (
    <ul>
      {users.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}

export default withFetchUsers(UserList);
```

이렇게 사용하면, 사용하는 부분에서는

```jsx
<UserList />
```

이렇게만 사용해도, 모든 과정을 수행할 수 있습니다. 여기서 더 나아간다면, props로 params값을 전달시켜서 새로운 요청을 보내개 한다던가, 이런식으로 확장이 가능합니다.

## 확장

도시도 처음부터 모든 서비스가 있는게 아니다. 인구가 늘어남에 따라서 서비스도 생겨난다. 하지만 성장에는 고통이 따른다. "확장"공사로 꽉 막힌 도로에서 "왜 처음 부터 넓게 만들기 않았지?"라고 자문한 적이 있을 것 이다. 성장할지 모른다는 기대로 조그마한 마을에 6차선 도로를 만들 순 없는 노릇이다.

'처음부터' 올바른 시스템을 만들 수 있는 믿음은 버려야 한다. 대신 우리는 오늘 주어진 사용자 스토리에 맞춰 시스템을 구현해야 한다. TDD, 리팩터링, 깨끗한 코드는 코드 수준에서 시스템을 조정하고 확장하기 쉽게 만들어준다.

하지만 시스템 수준에서는 어떨까? 시스템 아키텍처는 사전에 계획이 필요하지 않을까? 단순한 아키텍처를 복잡한 아키텍처로 조금씩 키울 수 없다늖 현실은 정확하다.

> 소프트웨어 시스템은 물리적인 시스템과 다르다. 관심사를 적절하게 분리해 관리한다면 소프트웨어 아키텍처는 점진적으로 발전할 수 있다.

관심사를 적절하게 분리하지 못하는 아키텍처 예시를 소개해 준다.

- 관심사가 분리되지 않아, 테스트나 기능을 독립적으로 수행하기 어렵다.

결국 객체지향프로그래밍이라는 개념조차 뿌리가 흔들린다고 말한다. DTO는 메서드가 없으면 사실상 구조체와 다르지 않다. 동일한 정보를 저장하는 자료 유형이 두 개라는 의미다. 한 객체에서 다른 객체로 자료를 복사하는 반복적인 규격 코드가 필요하다.

### 횡단 괌심사

하나의 관심사가 여러 모듈에 걸쳐서 있는 것을 횡단 관심사라고 부른다.

영속성( 데이터가 생성된 프로그램이 종료되더라도 사라지지 않고 유지되는 특성)을 예시로 설명하지만, 로깅, 보안, 캐싱 과 같은 모듈 전반적으로 사용되는 도메인도 여기에 해당한다.

이러한 동작을 처리하는 방식은 관점 지향 프로그래밍(AOP)의 일반적인 방법론이다.

API에서 관점이라는 구성 개념은 특정 관심사를 지원하려면 시스템에 특정 지점들이 동작하는 방식을 인관성 있게 바꿔야 한다. 라고 명시한다.

영속성을 예로들면, 프로그램머는 영속적으로 저장할 객체와 속성을 선언한 후 영속성 책임을 영속성 프레임워크에 위임한다. 그러면 AOP 프레임워크는 대상 코드에 영향을 미치지 않는 상태9로 동작 방식을 변경한다

> 뭔가 어렵게 쓰여져 있는데,쉽게 설명하면, AOP는 흩어진 관심사를 하나로 모아서 관리한다고 봐도 무방할 것 같습니다.

프론트엔드에서는 `상태`라는 개념이 존재합니다. 이 `상태`는 각 컴포넌트의 생명주기에 관여하는 하나의 `값`인데, 이 값이 해당 컴포넌트에서 벗어나, 다른 컴포넌트 에게까지 영향을 줄 때가 있습니다. 보통 자식이나, 부모간의 상태 전달이 일반적이지만, 아예 다른 컴포넌트에 상태를 전달해야하는 상황이 발생할 수 있습니다. 이 때 상태를 전역적으로 관리할 수 있는데, 이게 AOP관점과 조금 비슷한것 같아서 적어봅니다.

GPT한테 물어보니깐, 관점 자체는 유사하지만 하는 역할의 차이라고 합니다.
| 공통점 | 설명 |
| ---------- | ------------------------------------------- |
| 관심사 분리 | 전역 상태도 "상태"라는 관심사를 컴포넌트에서 분리함 |
| 코드 중복 방지 | AOP도, 전역 상태도 **중복되는 코드나 상태 관리**를 줄임 |
| 시스템 전반에 퍼짐 | AOP는 “로직에 퍼진 기능”, 전역 상태는 “UI 전반에 퍼진 상태”를 다룸 |

## 자바 프록시

프록시는 단순한 상황에 적합하다. 개별 객체나 클래스에서 메서드를 호출을 감싸는 경우가 좋을 예이다.

예제로 보여주는 코드에서는

정의된 메서드 사용과는 별개로, 추가로 필요한 Handler를 정의해서 추가로 실행하도록 한다.

프록시는 단점이 있는데

- 코드의 "양"
- 코드의 "크기"

프록시를 사용하면 깨끗한 코드를 작성하기 어렵다.
또 한 프록시는 시스템 단위로 실행 '지점'을 명시하는 메커니즘도 제공하지 않는다.

> 이 부분을 읽고, 프록시가 하는 일은 단순히 중간에 객체에 추가적인 기능을 넣기 위햇 사용하는 건가? 하는 생각을 하니깐 일전에 나왔던 DI와 무엇이 다르지? 라는 의문점이 들었습니다.

다음과 같은 차이점이 있다고 합니다.
| 항목 | 프록시 (Proxy) | DI 컨테이너 |
| ------ | ----------------------------------- | ------------------------------ |
| 목적 | **메서드 호출을 가로채어 부가 기능 삽입** | **객체 생성과 의존성 연결을 자동화** |
| 언제 작동? | **런타임** – 메서드 호출 시 | **앱 시작 시** – 객체 생성 시점 |
| 개입 대상 | **객체의 메서드 호출** | **객체 생성 시점과 주입 대상** |
| 예시 기능 | 로깅, 트랜잭션, 보안, 캐싱 등 | 의존성 관리, 모듈 연결, 생명주기 관리 등 |
| 결과 | 실제 객체와 동일한 인터페이스를 가진 **가짜 객체(대리자)** | 개발자가 `new` 없이 의존 객체를 **자동 주입** |

한 줄 정리하자면

- proxy는 객체를 가로채, 동작
- DI 컨테이너는 객체 생성과 연결의 자동화

## 순수 자바 AOP 프레임워크

다행스럽게도 대부분의 프록시 코드는 판박이라 도구로 자동화 할 수 있다. 스프링 비즈니스 논리를 POJO로 구현한다.

> POJO는 순수 자바로 프로그래밍한 Java의 핵심적인 개념을 담은 프로그래밍을 의미한다고 합니다.

POJO는 순수하게 도메인에 초점을 맞춘다. 그렇기 때문에 테스트가 개념적으로 더 쉽고 간단하다. 상대적으로 단순하기 때문에 사용하 스토리를 올리고 구현하기 쉬우며 미래 스토리에 맞춰 코드를 보수하고 개선하기 편하다.

프로그래머는 설정 파일이나 API를 활용해 필수적인 어플리케이션 기반을 구축한다. 이 때 프레임워크는 사용자가 모르게 프록시나 바이트코드 라이브러리를 활용해 이를 구현한다.

스프링 관련 자바 코드가 거의 필요없어 `사실상 스프링과 독립적이다.`
XML은 장황하고 읽기 어렵지다. 설정 파일에 명시된 정책이 겉으로 보이지 않지만 자동으로 생성하는 프록시나 관점 논리보다는 단순하다.

코드 자체는 깔끔하고 깨끗하다. 즉, 그 만큼 테스트하고 개선하고 보수하기 쉬워졌다.

## Aspect 관점

마지막 관심사는 관점으로 분리리하는 가장 강력한 도구 AspectJ언어다.

언어 차원에서 관점을 모듈화 구성한다.
강력하고 풍부한 도구 집합을 제공하지만 러닝커브가 좀 있다.

> 결국 위에서 말해준 Java의 관심사 분리에 대해 이야기 한 것은, 어떤식으로 관심사 분리가 가능한지에 대한 예시를 보여준 거라고 생각합니다.
> 사실 java부분 코드가 어려워서 좀 많이 넘기면서 보긴 했는데, 의미하는 바는

어떤 관점에서든 적절한 추상화와 (DI, proxy를 활용한) 모듈이 제공되는게 좋다는 것을 의미한 것 아닐까 하는 생각을 했습니다.

## 테스트 주도 시스템 아키텍처 구축

괌점으로 관심사를 분리하는 방식은 그 위력이 막강하다.
코드 수준에서 아키텍처 관심사를 분리할 수 있다면, 지정한 테스트 주도 아키텍처 구축이 가능해진다.

그때그때 새로운 기술을 채택해 단순한 아키텍처를 복잡한 아키텍처로 키워나갈 수 있다.

아주 단순하면서도 멋지게 분리된 아키텍처로 소프트웨어 프로젝트를 진행해 결과물을 재빨리 출시한 후, 기반 구조를 추가하며 조금씩 확장해 나가도 괜찮다.

세계 최대 웹 사이트들은 설계가 최대한 분리되어 각 추상화 수준과 범위에서 코드가 적당히 단순하기 때문에 높은 가용성과 성능 효율적이고 유연하게 발달했다.

그렇다고 아무 방향없이 프로젝트에 뛰어들어도 좋다는 소리는 아니다. 프로젝트를 시작할 때 일반적인 범위 목표 일정은 물론 결과를 내놓을 시스템의 일반적인 구조도 생각해야 한다. 하지만 변하느 ㄴ환경에 대처해 진로를 변경할 능력도 반드시 유지해야 한다.

> 처음부터 너무 많은 것을 잘하려고 하지마라 이런 의미이지 않나 싶습니다.

실제로 제가 모던애자일 활동을하면서 후배기수에게 제일 많이 했던 말이 할 수 있을 정도로 해라 MVP를 작게 잡고, 기능을 추가적으로 밀어 넣어라

이런 말을 좀 많이 했습니다. 제가 경험한 바로는 완성되는 기능들이 있어야 동기부여도 되고, 더 나아갈 원동력도 얻는다고 생각했습니다. 또한 그게 애자일이라고 생각했습니다.

하지만 이제는 제가 한 이야기에 추가적으로 설계를 잘 해라 확장을 위해 고려해야한다 라는 말을 아마 붙여줄 것 같습니다.

## 의사 결정을 최적화하라

- 모듈을 나누고
- 관심사를 분리하면

지엽적인 관리와 결정이 가능해진다.

아주 큰 시스템에서는 한 사람이 모든 결정을 내리기 어렵다. 때때론 가능한 마지막 순간까지 결정을 미루는 방법이 최선이다.

최대한 정보를 모아서 최선의 결정을 내리기 위해서이다.

## 명백한 가치가 있을 때 표준을 현며하게 사용하라

표준을 사용하면 아이디어와 컴포넌트를 재사용하기 쉽고, 적절한 경험을 가진 사람을 구하기 쉬우며, 좋은 아이디어를 캡슐화하기 쉽고, 컴포넌트를 엮기 쉽다.

## 시스템은 도메인 특화 언어가 필요하다.

DSL은 간단한 스크립트 언어나 표준 언어로 구현한 API를 가르킨다.

좋은 DSL은 도메인 개념과 그 개념을 구현한 코드 사이에 존재하는 '의사소통 간극'을 줄여준다. 애자일 기법이 팀과 프로젝트 이해관계자 사이에 의사소통 간극을 줄여주듯이 말이다.

효과적으로 DSL을 사용한다면 적절한 추상화 수준에서 코드 의도를 표현할 수 있다.

> 저는 DSL의 단점을 찾아봤습니다.

DSL은 잘쓰면 좋지만 무조건 쓰는게 좋은것은 아닙니다.

DSL은 코드의 비즈니스 의도를 명확하게 하고 가독성을 높인다는 점에서 유리합니다.
하지만 DSL구축은 복잡하고, 구현이 올바르게 되었는지 검증하고 유지보수 해야하는 책임이 따릅니다. 따라서 프로젝트에 DSL을 추가하는것이 투자대비 긍정적인 결과를 가져올 것인지 따져봐야 합니다.

간결하고 제한적인 언어에 도메인 지식을 담는것은 까다롭다고 합니다.

## 결로

시스템 역시 깨끗해야 한다.

모든 추상화 단계에서 의도는 명확히 표현해야 한다.

시스템을 설계하든 개별 모듈을 설계하든 실제로 돌아가는 가장 단순한 수단을 사용해야 한다.

# 감상문

설계를 명확하게 해야한다, 근데 단순하게 해라 뭐 말이 너무 어려웠습니다. 더군다나 Java로 설명하니깐 뭔 소리를 하는건지 알기가 어려웠습니다. 제가 느낀점은 방향성은 명확하게 하고, 그게 맞는 설계를 작성하라 라는 것 이었습니다. 너무 크게 설계를 하는게 아닌, 딱 내가 할 수 있을 만큼만을 설계하고, 그 설계에 있어서 어느정도의 확장성을 고려한다면 그게 좋은 설계가 아닐까 하는 생각을했습니다.

해당 장에서 설명하는 POJO나 DSL은 모두 Java에 해당하는 내용들이라 무시했고,
결국 중요한 것은, 이미 만들어 놓은 시스템을 적절히 잘 가져다가 사용하는 것

그리고 언어 수준에서 적절한 추상화와 모듈을 시킬 것

이 부분은 제가 중간에 한 번 언급한 `모노레포`가 좋은 예시인 것 같습니다. 각 모듈에 맞게 추상화된 내용을 잘 만들어 놓는다면, 확장에도 문제가 없고, 유지보수도 쉬워지니깐. 비슷하지 않나? 라는 생각을 한 것 같습니다.
