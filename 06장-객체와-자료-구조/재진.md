# 감상평

# 객체와 자료구조

- 변수를 비공개로 정의하는 이유는, 남들이 변수에 의존하지 않게 만들고 싶어서다.
- 충동이든, 변덕이든, 변수 타입이나 구현을 맘대로 바꾸고 싶어서다.

## 자료 추상화

```java
//구체적인 클래스
public class Point {
    public double x;
    public double y;
}
```

```java
//추상적인 클래스
public interface Point {
    double getX();
    double getY();
    void setCartesian(double x, double y);
    double getRO;
    double getTheta();
    void setPolar(double r, double theta);
}
```

- 위 코드는 직교좌표계를 사용한다.

> 좌표값을 읽고 설정하게 강제한다. 변수는 private로 설정하더라도, 각 조회(get), 설정(set) 함수를 제공한다면 외부로 노출하는 셈이다.
>
> - 변수 사이에 함수라는 계층을 넣는다고 해서 숨겨지는게 아니다. `구현을 감추려면 추상화`가 필요하다. 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있게 하는것이 진정한 의미의 클래스 이다.

- 아래 코드는 직교좌표계를 사용하는지, 극좌표계를 사용하는지 알 길이 없다.

> 단순 자료구조 이상을 표현한다. 클래스 메서드가 접근 정책을 강제한다.
> 좌표를 읽을 때 개별적으로 읽어야 하며, 좌표 설정시에는 두 값을 한 번에 설정해야 한다.

- 모든 자료를 세세하게 공개하기 보다는 추상적인 개념으로 표현하는 편이 좋다. 인터페이스나 조회/서정 함수만으로는 추상화가 이뤄지지 않는다.
- 그렇기 땜누에 객체가 포함하는 자료를 표현할 가장 좋은 방법을 심각하게 고민해야 한다.

> 왜 추상적인 개념으로 표현하는 편이 좋다고 하는지에 대한 의문이 들었습니다. 그냥 직관적으로 어떤 데이터를 다루고 있는지 알려주는 편이 이해하기도 편한거 아닌가? 라는 생각도 들었구요

- 여기에는 여러가지 의견이 있습니다.

1. 핵심 전달에 집중
   - 세부 정보가 지나치게 많으면 오히려 핵심이 흐려지고, 청자에게 혼란을 줄 수 있습니다.
     추상화는 핵심 메시지에 집중할 수 있게 하며, 불필요한 정보로 인한 인지적 부담을 줄여줍니다.
2. 확장성 및 유연성

   - 같은 데이터를 활용하더라도 추상화된 개념을 사용하면 다양한 맥락에서 유연하게 적용할 수 있습니다.
   - 예시를 들어보자면

   ```js
   name: "이재진";
   ```

   이라는 구체적인 데이터는 단순히 "이재진"이라는 이름만을 의미합니다. 그러나 추상화된 함수명으로 표현하면 의미가 훨씬 확장됩니다:

   - `getNamesBelongingToSchool` 특정 학교에 속한 이름 가져오기
   - `getRetrieveNamesOfRegisteredExam` 시험에 등록한 사람들의 이름 가져오기

   이처럼 데이터의 의미가 함수나 사용 맥락에 따라 달라질 수 있어 재사용성과 유연성이 높아집니다.

3. 정보의 보안과 통제
   - 추상적인 개념으로 표현하면 민감한 세부 정보를 직접적으로 노출하지 않으면서도 필요한 범위 내에서 정보를 공유할 수 있습니다.
     정보를 통제하면서도 의도를 전달할 수 있는 효과적인 방식입니다.

위 내용은 제가 이 글을 읽고, 글쓴이가 왜 추상화를 중요하게 생각했는지에 대한 개인적인 의견입니다.

## 자료/객체 비대칭

- 객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다.
- 자료구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다.

위 두 개념은 사실상 정반대다

```java
//절차적인 도형
public class Square {
    public Point topLeft;
    public double side;
}

public class Rectangle {
    public Point topLeft;
    public double height;
    public double width;
}

public class Circle {
    public Point center;
    public double radius;
}

public class NoSuchShapeException extends Exception {
    public NoSuchShapeException() {
        super("지원하지 않는 도형입니다.");
    }
}

public class Geometry {
    public final double PI = 3.141592653589793;

    public double area(Object shape) throws NoSuchShapeException {
        if (shape instanceof Square) {
            Square s = (Square) shape;
            return s.side * s.side;
        }
        else if (shape instanceof Rectangle) {
            Rectangle r = (Rectangle) shape;
            return r.height * r.width;
        }
        else if (shape instanceof Circle) {
            Circle c = (Circle) shape;
            return PI * c.radius * c.radius;
        }

        throw new NoSuchShapeException();
    }
}
```

객체 지향 프로그래머가 클래스가 절차적이라 비판한다면 맞는 말이다.

> 왜 객체 지향 프로그래머가 절차적이라고 비판할까 gpt를 돌려봤습니다.

객체지향 관점에서 넓이를 구하는 로직이 각 도형 클래스 안에 있어야 좋다고 합니다.
Square, Rectangle, Circle 각각이 area()라는 메서드를 갖고 직접 넓이를 계산해야 한다는 것 이죠,
그런데 위 코드는 Geometry 클래스 하나에 도형별 계산 로직이 전부 들어가 있습니다.
그래서 절차적이라고 비판하는 것 입니다.

- 이런 비판은 100% 옳다고 할 순 없다.
  둘레 길이를 구하는 perimeter() 함수를 추가하고 싶다면, 도형 클래스는 아무 영향도 받지 않는다. 그저 Geometry 클래스에 둘레 계산 로직을 추가하면 된다.

```java
//다형적인 도형
public class Square implements Shape {
  private Point topLeft;
  private double side;

  public double area() {
    return side*side;
  }

  public class Rectangle implements Shape {
    private Point topLeft;
    private double height;
    private double width;

    public double area() {
      return height * width;
    }
  }

  public class Circle implements Shape {
    private Point center;
    private double radius;
    public final double PI  = 3.1415926535589793;

    public double area() {
      return PI * radius * radius;
    }
  }
}
```

- (자료구조를 사용하는) 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 어렵다.
- 반대로, 객체 지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.

반대도 참이다.

- 절차적인 코드는 새로운 자료구조를 추가하기 어렵다. 모든 함수를 고쳐야 하기 때문
- 객체 지향 코드느 새로운 함수를 추가하기 어렵다. 그러려면 모든 클래스를 고쳐야 한다.

> 결론적으로, 객체지향 코드에서 어려운 변경은 절차적인 코드에서 쉬우며, 절차적인 코드에서 어려운 변경은 객체 지향코드에서 쉽다.

> react의 경우에는 객체 지향도, 절차 지향도 아닌 함수형 프로그래밍(Functional programming)기법을 사용합니다. 그래서 저는 객체 지향이니, 절차 지향이니 하는걸 잘 몰랐습니다.

> 해당 챕터를 읽으면서 어떤 상황에 절차와, 객체 지향중 더 적절한 방식을 선택할 수 있는 법에 대해서 알게 된 것 같아서 좋았습니다.
