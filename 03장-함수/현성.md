# ⭐ 감상문

## 3장 함수

### 작게 만들어라!

- 함수를 만드는 첫쨰 규칙은 '작게!'다. 함수를 만드는 둘째 규칙은 '더 작게!'다.

---

#### 블록과 들여쓰기

- 함수에서 들여쓰기(Depth) 수준은 1단이나 2단을 넘어서면 안 된다.
- 이는 if/else/while 문 등에 들어가는 블록을 한 줄(주로 함수 호출)로 만들어야 함을 의미한다.

---

### 한 가지만 해라!

- 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.
- '한 가지'를 하는지 판단하는 기준: 함수 내 모든 단계가 동일한 추상화 수준에 있어야 한다. 의미 있는 다른 이름으로 또 다른 함수를 추출할 수 있다면 여러 작업을 하는 것이다.

> 함수에 한 가지 역할만 부여하는 것은 저 또한 매우 중요하다고 생각합니다. 프론트엔드 개발에서도, 예를 들어 버튼의 onClick 이벤트에서 페이지를 이동하거나 모달을 띄워야 하는 경우가 있습니다. 이때 onClick 속성 안에 여러 작업을 직접 작성하기보다는, 별도의 함수를 만들어 호출하는 방식을 사용하고 있습니다. 하지만 하나의 함수가 여러 역할을 하게 되면, 적절한 함수명을 짓기가 어렵다는 점을 자주 느꼈습니다. 그래서 결국 하나의 역할만 수행하는 여러 개의 작은 함수로 나누는 방식이 더 좋다고 생각하게 되었습니다.

#### 함수 내 섹션

- 한 가지 작업만 하는 함수는 자연스럽게 섹션으로 나누기 어렵다.

---

### 함수 당 추상화 수준은 하나로!

- 함수가 확실히 ‘한 가지’ 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다.
- 서로 다른 추상화 수준을 섞으면 코드를 이해하기 어렵고, 불필요한 세부사항이 계속 추가될 수 있다.

#### 위에서 아래로 코드 읽기: 내려가기 규칙

- 코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 즉, 함수를 호출하면 그 함수 다음에는 한 단계 더 낮은 추상화 수준의 함수가 나와야 한다. 이를 통해 프로그램의 추상화 수준이 단계적으로 낮아지도록 구성한다.

> 솔직히 여태까지 이런 부분에 대해 깊게 생각해본 적이 없었습니다. 단순히 코드를 위에서 아래로 읽을 수 있어야 한다는 것만 중요하다고 여겼는데, '추상화 단계'를 낮춘다는 개념이 꽤나 신선하게 다가왔습니다. 지금까지는 추상화 수준이 높은 함수라면 코드 내부를 보지 않아도 되니까 무조건 좋은 것이라고 생각했는데, 결국 높은 추상화는 하나의 틀을 마련하는 것이고, 그 안에서 점점 추상화를 낮추면 구체적인 내용을 채워나갈 수 있으니 더 좋은 코드를 작성할 수 있겠네요.

---

### Switch 문

- Switch 문은 작게 만들기 어렵고, 본질적으로 N가지 작업을 처리하므로 '한 가지 작업' 원칙을 지키기도 어렵다.
- 필요하다면 다형성을 이용하여 저수준 클래스나 추상 팩토리에 숨겨 반복을 피하는 것이 좋다.
- 다형적 객체를 생성하는 코드 내에서는 한 번 정도 사용될 수 있다.

---

### 서술적인 이름을 사용하라!

- 함수가 하는 일을 잘 표현하는 서술적인 이름을 사용해야 한다.
- 이름이 길어져도 괜찮다. 길고 서술적인 이름이 짧고 모호한 이름이나 길고 서술적인 주석보다 훨씬 낫다.
- 함수가 작고 단순할수록 서술적인 이름을 고르기 쉽다.
- 이름을 붙일 때는 일관성 있는 용어를 사용해야 코드를 이해하기 쉽다.

---

### 함수 인수

- 함수에서 이상적인 인수 개수는 0개(무항)이고, 다음은 1개(단항)고, 다음은 2개(이항) 순이다. 3개(삼항)는 가능한 피하고, 4개 이상은 특별한 이유 없이는 사용하지 않는 것이 좋다.

> 인수의 개수를 적게하는 노력이 필요한 건 맞는 것 같습니다. 그런데 이건 개인적으로 제가 좋아하는 RORO 패턴으로 이를 어느정도 해결할 수 있다고 생각합니다.

RORO(Request Object Response Object): 매개변수로 객체를 받고 반환할 때도 무조건 객체로 반환하는 패턴

RORO 사용하지 않은 경우

```js
function size(top, bottom, left, right, type) {
  console.log(top, bottom, left, right);
};

// 호출
size(10, 20, 30, 40, 'circle');

```

RORO 사용한 경우

```js
function size({ top, bottom, left, right, type }) {
  console.log(top, bottom, left, right, type);
};

// 호출
size({
  top: 10,
  bottom: 20,
  left: 30,
  right: 40,
  type: 'circle'
});
```

참고문헌: [ZeroCho TV - 매개변수가 많을 때 좋은 RORO 패턴](https://www.youtube.com/watch?v=xirRddcqbrU&ab_channel=ZeroChoTV)

#### 많이 쓰는 단항 형식

- **인수에 질문하기:** `boolean fileExists("MyFile")`처럼 인수에 대해 질문하고 boolean 값을 반환한다.
- **인수 변환:** `InputStream fileOpen("MyFile")`처럼 인수를 다른 형태로 변환하여 결과를 반환한다. (이때 결과는 반환값으로 돌려주어야 하며, 출력 인수를 사용하면 안 된다.)
- **이벤트:** 입력 인수만 있고 반환값은 없다. 입력 인수로 시스템 상태를 바꾼다. (`passwordAttemptFailedNtimes(int attempts)`) 이름과 문맥으로 이벤트임을 명확히 해야 한다.

#### 플래그 인수

- 함수에 boolean 값을 넘기는 플래그 인수는 추하다. 이는 함수가 한꺼번에 여러 가지 작업을 처리한다는 것을 의미하므로 함수를 분리해야 한다.

> 플래그 인수는 함수가 특정 동작을 수행할지 여부를 결정하는 데 사용되는 인자로, 주로 불리언(boolean)이나 문자열(string), 열거형(enum) 값 등을 사용한다고 합니다.

#### 이항 함수

- 인수가 2개인 함수는 인수가 1개인 함수보다 이해하기 어렵다.
- 인수가 자연스러운 순서를 가지고 하나의 개념(값)을 표현할 때(`Point(x, y)`)는 괜찮지만, 그렇지 않은 경우는 혼란을 야기할 수 있다. 가능하면 단항 함수로 바꾸는 것을 고려한다.

#### 삼항 함수

- 이항 함수보다 훨씬 이해하기 어렵다. 순서, 의미 파악의 어려움이 배가되므로 만들 때 신중해야 한다.

#### 인수 객체

- 인수가 2~3개 필요하다면 객체를 생성해 인수를 줄이는 방법을 사용한다. (예: `makeCircle(Point center, double radius)`)

#### 인수 목록

- 때로는 가변 인수(`String... args`)가 필요할 수 있다 (`String.format`). 가변 인수를 받는 함수는 개념적으로는 인수가 하나(List) 또는 둘인 함수로 취급될 수 있다.

#### 동사와 키워드

-

---

### 부수 효과를 일으키지 마라!

-

#### 출력 인수

-

---

### 명령과 조회를 분리하라!

-

---

### 오류 코드보다 예외를 사용하라

-

#### Try/Catch 블록 뽑아내기

-

#### 오류 처리도 한 가지 작업이다.

-

#### Error.java 의존성 자석

-

---

### 반복하지 마라!

-

---

### 구조적 프로그래밍

-

---

### 함수를 어떻게 짜죠?

-

---

### 결론

-

---
