# ⭐ 감상문

3장을 읽으면서 가장 크게 배운 점은 함수는 한 가지 일을 잘 해야 한다는 점입니다. 함수의 역할을 명확히 하는 것이 얼마나 중요한지 다시금 깨닫게 되는 부분이었습니다.

또한 '함수를 어떻게 짜죠?' 파트에서 큰 위안을 얻었습니다. 클린코드를 지향하는 과정이 처음부터 완벽한 코드를 짜는 것이 아닌, 생각을 기록하고 테스트하며 점진적으로 다듬어가는 글쓰기와 같다는 비유라는 것이 결국 '깨끗한 코드'는 끊임없이 개선하는 리팩토링의는 결과물이라는 사실을 받아들이게 되었습니다.

## 3장 함수

### 작게 만들어라!

- 함수를 만드는 첫쨰 규칙은 '작게!'다. 함수를 만드는 둘째 규칙은 '더 작게!'다.

---

#### 블록과 들여쓰기

- 함수에서 들여쓰기(Depth) 수준은 1단이나 2단을 넘어서면 안 된다.
- 이는 if/else/while 문 등에 들어가는 블록을 한 줄(주로 함수 호출)로 만들어야 함을 의미한다.

---

### 한 가지만 해라!

- 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.
- '한 가지'를 하는지 판단하는 기준: 함수 내 모든 단계가 동일한 추상화 수준에 있어야 한다. 의미 있는 다른 이름으로 또 다른 함수를 추출할 수 있다면 여러 작업을 하는 것이다.

> 함수에 한 가지 역할만 부여하는 것은 저 또한 매우 중요하다고 생각합니다. 프론트엔드 개발에서도, 예를 들어 버튼의 onClick 이벤트에서 페이지를 이동하거나 모달을 띄워야 하는 경우가 있습니다. 이때 onClick 속성 안에 여러 작업을 직접 작성하기보다는, 별도의 함수를 만들어 호출하는 방식을 사용하고 있습니다. 하지만 하나의 함수가 여러 역할을 하게 되면, 적절한 함수명을 짓기가 어렵다는 점을 자주 느꼈습니다. 그래서 결국 하나의 역할만 수행하는 여러 개의 작은 함수로 나누는 방식이 더 좋다고 생각하게 되었습니다.

#### 함수 내 섹션

- 한 가지 작업만 하는 함수는 자연스럽게 섹션으로 나누기 어렵다.

---

### 함수 당 추상화 수준은 하나로!

- 함수가 확실히 ‘한 가지’ 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다.
- 서로 다른 추상화 수준을 섞으면 코드를 이해하기 어렵고, 불필요한 세부사항이 계속 추가될 수 있다.

#### 위에서 아래로 코드 읽기: 내려가기 규칙

- 코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 즉, 함수를 호출하면 그 함수 다음에는 한 단계 더 낮은 추상화 수준의 함수가 나와야 한다. 이를 통해 프로그램의 추상화 수준이 단계적으로 낮아지도록 구성한다.

> 솔직히 여태까지 이런 부분에 대해 깊게 생각해본 적이 없었습니다. 단순히 코드를 위에서 아래로 읽을 수 있어야 한다는 것만 중요하다고 여겼는데, '추상화 단계'를 낮춘다는 개념이 꽤나 신선하게 다가왔습니다. 지금까지는 추상화 수준이 높은 함수라면 코드 내부를 보지 않아도 되니까 무조건 좋은 것이라고 생각했는데, 결국 높은 추상화는 하나의 틀을 마련하는 것이고, 그 안에서 점점 추상화를 낮추면 구체적인 내용을 채워나갈 수 있으니 더 좋은 코드를 작성할 수 있겠네요.

---

### Switch 문

- Switch 문은 작게 만들기 어렵고, 본질적으로 N가지 작업을 처리하므로 '한 가지 작업' 원칙을 지키기도 어렵다.
- 필요하다면 다형성을 이용하여 저수준 클래스나 추상 팩토리에 숨겨 반복을 피하는 것이 좋다.
- 다형적 객체를 생성하는 코드 내에서는 한 번 정도 사용될 수 있다.

---

### 서술적인 이름을 사용하라!

- 함수가 하는 일을 잘 표현하는 서술적인 이름을 사용해야 한다.
- 이름이 길어져도 괜찮다. 길고 서술적인 이름이 짧고 모호한 이름이나 길고 서술적인 주석보다 훨씬 낫다.
- 함수가 작고 단순할수록 서술적인 이름을 고르기 쉽다.
- 이름을 붙일 때는 일관성 있는 용어를 사용해야 코드를 이해하기 쉽다.

---

### 함수 인수

- 함수에서 이상적인 인수 개수는 0개(무항)이고, 다음은 1개(단항)고, 다음은 2개(이항) 순이다. 3개(삼항)는 가능한 피하고, 4개 이상은 특별한 이유 없이는 사용하지 않는 것이 좋다.

> 인수의 개수를 적게하는 노력이 필요한 건 맞는 것 같습니다. 그런데 이건 개인적으로 제가 좋아하는 RORO 패턴으로 이를 어느정도 해결할 수 있다고 생각합니다.

RORO(Request Object Response Object): 매개변수로 객체를 받고 반환할 때도 무조건 객체로 반환하는 패턴

RORO 사용하지 않은 경우

```js
function size(top, bottom, left, right, type) {
  console.log(top, bottom, left, right);
};

// 호출
size(10, 20, 30, 40, 'circle');

```

RORO 사용한 경우

```js
function size({ top, bottom, left, right, type }) {
  console.log(top, bottom, left, right, type);
};

// 호출
size({
  top: 10,
  bottom: 20,
  left: 30,
  right: 40,
  type: 'circle'
});
```

참고문헌: [ZeroCho TV - 매개변수가 많을 때 좋은 RORO 패턴](https://www.youtube.com/watch?v=xirRddcqbrU&ab_channel=ZeroChoTV)

#### 많이 쓰는 단항 형식

- **인수에 질문하기:** `boolean fileExists("MyFile")`처럼 인수에 대해 질문하고 boolean 값을 반환한다.
- **인수 변환:** `InputStream fileOpen("MyFile")`처럼 인수를 다른 형태로 변환하여 결과를 반환한다. (이때 결과는 반환값으로 돌려주어야 하며, 출력 인수를 사용하면 안 된다.)
- **이벤트:** 입력 인수만 있고 반환값은 없다. 입력 인수로 시스템 상태를 바꾼다. (`passwordAttemptFailedNtimes(int attempts)`) 이름과 문맥으로 이벤트임을 명확히 해야 한다.

#### 플래그 인수

- 함수에 boolean 값을 넘기는 플래그 인수는 추하다. 이는 함수가 한꺼번에 여러 가지 작업을 처리한다는 것을 의미하므로 함수를 분리해야 한다.

> 플래그 인수는 함수가 특정 동작을 수행할지 여부를 결정하는 데 사용되는 인자로, 주로 불리언(boolean)이나 문자열(string), 열거형(enum) 값 등을 사용한다고 합니다.

#### 이항 함수

- 인수가 2개인 함수는 인수가 1개인 함수보다 이해하기 어렵다.
- 인수가 자연스러운 순서를 가지고 하나의 개념(값)을 표현할 때(`Point(x, y)`)는 괜찮지만, 그렇지 않은 경우는 혼란을 야기할 수 있다. 가능하면 단항 함수로 바꾸는 것을 고려한다.

#### 삼항 함수

- 이항 함수보다 훨씬 이해하기 어렵다. 순서, 의미 파악의 어려움이 배가되므로 만들 때 신중해야 한다.

#### 인수 객체

- 인수가 2~3개 필요하다면 객체를 생성해 인수를 줄이는 방법을 사용한다. (예: `makeCircle(Point center, double radius)`)

#### 인수 목록

- 때로는 가변 인수(`String... args`)가 필요할 수 있다 (`String.format`). 가변 인수를 받는 함수는 개념적으로는 인수가 하나(List) 또는 둘인 함수로 취급될 수 있다.

#### 동사와 키워드

- 함수의 의도나 인수의 순서와 의도를 제대로 표현하려면 좋은 함수 이름이 필수다.
- 단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 한다.

> 여기서 코드팩토리 유튜버가 동사가 없는 함수명은 쓰지말라고 했던 게 생각이 났습니다. 코드 예제도 비슷한 게 그저 `file`이라고만 작성하는 게 아니라 `readFile`로 함수명을 작성하면 동작이 무엇인지 알 수 있기 때문에 함수명에는 동사를 사용하는 것이 좋다고 하더라고요.

참고 문헌: [코드팩토리 - 변수 이름 작명 마스터클래스](https://www.youtube.com/watch?v=dQzsgQnpufk)

---

### 부수 효과를 일으키지 마라!

- 부수 효과는 예상치 못한 결과를 낳고, 시간적인 결합이나 순서 종속성을 초래할 수 있다.

> 부수 효과 자체가 클린코드에서 지금껏 이야기했던 함수의 '한 가지 원칙'을 어기는 것과 비슷한 것 같습니다. 저는 그 원칙에 대해 한 번 더 강조하는 것 같다고 느꼇습니다.

#### 출력 인수

- 일반적으로 출력 인수는 피해야 한다.
- 함수에서 상태를 변경해야 한다면 함수가 속한 객체 상태를 변경하는 방식을 택한다.

---

### 명령과 조회를 분리하라!

- 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다.

> 결국 이 또한 '한 가지 원칙'을 강조하는 것 같습니다. 함수가 뭔가를 수행하는 것과 뭔가에 답하는 것은 서로 다른 작업이기 때문에, 이를 분리하여 작성하는 것이 확실한 코드를 작성하는 데 도움이 될 것 같습니다.

---

### 오류 코드보다 예외를 사용하라

- 오류 코드 대신 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리되므로 코드가 깔끔해진다.

> 여기서 핵심적으로 말하려는 것은 결국 오류 처리와 비즈니스 로직을 분리하라는 것 같습니다. 코드의 가독성을 높이기 위해서도 좋고, 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리되므로 코드가 깔끔해진다는 점을 강조하는 것 같습니다.

#### Try/Catch 블록 뽑아내기

- try/catch 블록은 코드 구조에 혼란을 일으키며, 정상 동작과 오류 처리 동작을 뒤섞기 때문에 try/catch 블록을 별도 함수로 뽑아내는 것이 좋다.

#### 오류 처리도 한 가지 작업이다.

- 오류를 처리하는 함수는 오류만 처리해야 마땅하다.

#### Error.java 의존성 자석

```java
public enum Error {
  OK,
  INVALID,
  N0_SUCH,
  LOCKED,
  OUT_OF_RESOURCES,
  WAITING_FOR_EVENT；
}
```

- 위와 같은 클래스는 의존성 자석이다. 다른 클래스에서 이 클래스를 사용하면 그 클래스는 Error.java에 의존하게 된다.
- Error enum이 변한다면 그에 의존하는 모든 클래스도 영향을 받기 때문에 변경이 어려워진다.

---

### 반복하지 마라!

- 어쩌면 중복은 소프트웨어에서 모든 악의 근원이다.
- 많은 원칙과 기법이 중복을 없애거나 제어할 목적으로 나왔다.

> 생각해보면 지금껏 프로그래밍 역사에서는 반복(중복)을 피하기 위해 클래스, 함수, 모듈 등을 도입해 온 것 같네요.

---

### 구조적 프로그래밍

- 모든 함수와 함수 내 모든 블록에 입구와 출구가 하나만 존재해야 한다. 즉, 함수는 return 문이 하나여야 한다.

---

### 함수를 어떻게 짜죠?

- 소프트웨어를 짜는 행위는 여느 글짓기와 비슷하다. 논문이나 기사를 작성할 때는 먼저 생각을 기록한 후 읽기 좋게 다듬는다.

> 클린코드를 읽으면서 계속 든 생각은 '이 사람은 처음부터 완벽을 추구하고 코드를 짜는 것인가?'였었는데 해당 파트에서 저자의 인간성이 느껴졌습니다. 특히 마지막 문장에 처음부터 탁 짜내지 않는다며 그게 가능한 사람은 없으리라고 한 부분이 왠지 모를 안도감이 들었습니다...

---

### 결론

- 모든 시스템은 특정 응용 분야 시스템을 기술할 목적으로 프로그래머가 설계한 도메인 특화 언어로(DSL) 만들어지며, 함수는 그 언어에서 동사며, 클래스는 명사다.
- 이 장에서 설명한 규칙들을 따르면 함수를 더 작고, 이름이 좋으며, 체계적으로 만들 수 있다. 궁극적인 목표는 시스템이라는 이야기를 잘 풀어가는 것이다.

---
