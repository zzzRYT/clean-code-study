# 감상문

# 03장 함수

---

책에서는 예시 코드가 주어진다.
FtiNesse의 긴 함수를 예시로 들어주는데, 이 코느는 파악하기 힘든 코드의 예시를 보여준다.
그리고 다음으로 구조를 조금 변경한 하나의 다른 함수를 보여준다.

두 코드의 차이는, 메소드를 분리하고, 이름을 명확하게 만들고, 이해하기 쉽도록 함수 내부 코드를 간략화 시켰다.

> 저는 자바를 공부하고 있지도 않고, 얕은 지식으로는 명확한 코드를 파악하기 어려웠습니다. 그럼에도, 3-1에서 보여준 코드와, 3-2에서 보여준 코드가 무엇을 의미하는지 명확하게 알 수 있었습니다.

---

## 작게 만들어라!

- 함수를 만드는 첫 번째 규칙: '작게'
- 두 번째 규칙: '더 작게'

작을수록 좋다는 증거를 제시할 순 없지만, 글쓴이의 경험으로 비춰봤을 때 , 300줄 되는 코드보다는 30줄 되는 코드가 좋다고 한다. 그래서 위에서 설명했던, 3-2 코드를 한 번 더 줄인다.

### 블록과 들여쓰기

if, else, while과 같은 블록은 한 줄이어야 한다고 한다. 보통 그 내부에서는 함수를 호출하기에, 바깥을 감싸는 함수의 길이가 작아질 뿐 아니라, 블록 안에서 호출하는 함수 이름을 적절하게 짓는다면, 코드를 이해아기 더 쉬워진다고 한다.

다른 말로는, 함수가 중첩 구조가 생길 만큼 커져서는 안된다고도 설명한다.

> 여기서는 하나의 함수 로직이 3 4줄 정도로 끝나야 한다고 말하지만, 현실에서는 그정도로 함수를 작게 만드는건 굉장히 어려운 것 같습니다. 처음부터 작게 만들어야지 하는게 아니라, 점진적으로 리팩터링을 통해서 작게 만드는 노력을 해야할 것 같습니다.

---

## 한 가지만 해라!

> 함수는 한 가지를 해야 한다. 그 한가지를 잘 해야 한다. 그 한가지만을 해야한다.

```java
public static String renderPageWithSetupsAndTeardowns(
 PageData pageData, boolean isSuite) throws Exception {
 if (isTestPage(pageData))
 includeSetupAndTeardownPages(pageData, isSuite);
 return pageData.getHtml();
}
```

해당 코드가 한 자기만 하는가?

1. 페이지가 테스트 페이지인지 판단한다.
2. 그렇다면 설정 페이지와 해제 페이지를 넣는다.
3. 페이지를 HTML로 렌더링 한다.

이렇게 되면 한 가지가 아닌게 아닌가?
위에서 언급한 세 단계는 지정된 함수 이름 아래에서 추상화 수준이 하나다.

> 페이지가 테스트 페이지인지 확인한 후 테스트 페이지라면 설정 페이지와 해제 페이지를 넣는다. 테스트 페이지든 아니든 페이지를 HTML로 렌더링 한다.

지정된 함수 이름 아래에 추상화 수준이 하나인 단계만 수행한다.

> 위 내용에 대해서 어째서 하나의 추상화로 동작하는지 이해가 잘 안돼서 gpt한테 부탁하니 이런 답을 내주었습니다.

- `isTestPage()` → 판단

- `includeSetupAndTeardownPages()` → 조건에 따라 설정/해제 포함

- `getHtml()` → HTML 렌더링

"테스트 페이지라면 설정과 해제를 포함해서 HTML을 반환한다" 라는 고수준 행위에 대한 세부적인 작업들의 나열이기 때문에 하나의 추상화로 구분할 수 있는 거라고 합니다.

즉, 하나의 고수준 목표를 위한 세부적인 하위 단계를 의미합니다.

---

## 함수 당 추상화 수준은 하나로!

함수가 확실히 '한 가지' 작업만 하려면 함수 내 모든 문장의 추상화 수준을 동일하게 해야 한다.

- getHtml() -> 추상화 수준 높음
- String pagePathName = PathParser.render(pagePath) -> 추상화 수준 중간
- .append("") -> 추상화 수준 낮음

같은 함수 내에서 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다.

> 이 추상화라는게 어떤식으로 구분되는지 궁금해서 gpt한테 물어봤습니다.

추상화의 수준을 `고수준`과 `저수준`으로 구분하는데,
`고수준`은 **무엇을 하는가**
`저수준`은 **어떻게 하는가**
라고 이야기 합니다.

예시를 보면서 이해해보면,

```js
function sendWelcomeEmail(user) {
  const email = createWelcomeEmail(user);
  sendEmailToUser(user.email, email);
}
```

`sendWelcomeEmail`라는 함수이름은 "이메일에 Welcome을 보낸다"라는 **무엇을 하는가** 에 해당하는 `고수준`추상화 입니다.
그리고 내부에서는 그에 맞는
`createWelcomeEmail`과 `sendEmailToUser`라는 결국 Email로 Welcome이라는 메시지를 send하기위한 일련의 과정을 추상화 해둔 `중간 수준`의 추상화를 제공합니다.

그러면 잘못된 예시도 한 번 봐야겠네요

```js
function sendWelcomeEmail(user) {
  const email = {
    subject: "Welcome!",
    body: `Hello ${user.name}, thanks for signing up!`,
  };
  smtp.send({
    to: user.email,
    subject: email.subject,
    body: email.body,
  });
}
```

동일한 코드인데 뭐가 잘못됐는지 보이시나요?
함수의 이름이 `sendWelcomeEmail`라는 고수준에 `대한하는 **무엇을 하는가**에 대해서 이야기 합니다.
하지만 내부 로직에서는
email에 객체를 직접 할당하거나, smtp로 직접 메일을 보내고 있는 **어떻게 하는가** 에 대한 `저수준`추상화를 제공합니다.

그렇기 때문에 **고수준**의 함수명과 다르게, 내부에서는 **저수준**의 추상화를 제공해 코드를 읽어 내려가는 사람이 읽는데 어려움을 겪을 수 있습니다.

### 위에서 아래로 코드 읽기: *내려가기*규칙
