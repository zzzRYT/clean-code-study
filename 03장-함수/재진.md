# 감상문

- 해당 장에서는 함수를 작성하는 이야기를 합니다.

나름 다음과 같이 정리할 수 있을 것 같습니다.

- 함수의 이름을 바꾸기
- 함수 내부의 코드를 간소화 한다
- 간소화를 위해, 여러 함수로 분리한다.
- 하나의 함수에는 한 가지의 역할을 부여해라.
- 중복을 없애라
- 해당 함수와 관련없는 내용은 없애고, 함수 이름을 봤을 때, 이해할 수 있도록 작성해라

이정도 인 것 같습니다.

해당 내용은들은 이 책을 보기 전에도 어느정도 생각할 수 있는 부분이기도 했고, 리팩터링을 진행할 때, 해당 사항에 맞게 진행해야한다는 것 쯤은 알고 있었습니다.

하지만, 이 책으 읽으면서 조금 확신을 가지고, 작업을 할 수 있을것 같다는 생각을 했습니다.

# 03장 함수

---

책에서는 예시 코드가 주어진다.
FtiNesse의 긴 함수를 예시로 들어주는데, 이 코느는 파악하기 힘든 코드의 예시를 보여준다.
그리고 다음으로 구조를 조금 변경한 하나의 다른 함수를 보여준다.

두 코드의 차이는, 메소드를 분리하고, 이름을 명확하게 만들고, 이해하기 쉽도록 함수 내부 코드를 간략화 시켰다.

> 저는 자바를 공부하고 있지도 않고, 얕은 지식으로는 명확한 코드를 파악하기 어려웠습니다. 그럼에도, 3-1에서 보여준 코드와, 3-2에서 보여준 코드가 무엇을 의미하는지 명확하게 알 수 있었습니다.

---

## 작게 만들어라!

- 함수를 만드는 첫 번째 규칙: '작게'
- 두 번째 규칙: '더 작게'

작을수록 좋다는 증거를 제시할 순 없지만, 글쓴이의 경험으로 비춰봤을 때 , 300줄 되는 코드보다는 30줄 되는 코드가 좋다고 한다. 그래서 위에서 설명했던, 3-2 코드를 한 번 더 줄인다.

### 블록과 들여쓰기

if, else, while과 같은 블록은 한 줄이어야 한다고 한다. 보통 그 내부에서는 함수를 호출하기에, 바깥을 감싸는 함수의 길이가 작아질 뿐 아니라, 블록 안에서 호출하는 함수 이름을 적절하게 짓는다면, 코드를 이해아기 더 쉬워진다고 한다.

다른 말로는, 함수가 중첩 구조가 생길 만큼 커져서는 안된다고도 설명한다.

> 여기서는 하나의 함수 로직이 3 4줄 정도로 끝나야 한다고 말하지만, 현실에서는 그정도로 함수를 작게 만드는건 굉장히 어려운 것 같습니다. 처음부터 작게 만들어야지 하는게 아니라, 점진적으로 리팩터링을 통해서 작게 만드는 노력을 해야할 것 같습니다.

---

## 한 가지만 해라!

> 함수는 한 가지를 해야 한다. 그 한가지를 잘 해야 한다. 그 한가지만을 해야한다.

```java
public static String renderPageWithSetupsAndTeardowns(
 PageData pageData, boolean isSuite) throws Exception {
 if (isTestPage(pageData))
 includeSetupAndTeardownPages(pageData, isSuite);
 return pageData.getHtml();
}
```

해당 코드가 한 자기만 하는가?

1. 페이지가 테스트 페이지인지 판단한다.
2. 그렇다면 설정 페이지와 해제 페이지를 넣는다.
3. 페이지를 HTML로 렌더링 한다.

이렇게 되면 한 가지가 아닌게 아닌가?
위에서 언급한 세 단계는 지정된 함수 이름 아래에서 추상화 수준이 하나다.

> 페이지가 테스트 페이지인지 확인한 후 테스트 페이지라면 설정 페이지와 해제 페이지를 넣는다. 테스트 페이지든 아니든 페이지를 HTML로 렌더링 한다.

지정된 함수 이름 아래에 추상화 수준이 하나인 단계만 수행한다.

> 위 내용에 대해서 어째서 하나의 추상화로 동작하는지 이해가 잘 안돼서 gpt한테 부탁하니 이런 답을 내주었습니다.

- `isTestPage()` → 판단

- `includeSetupAndTeardownPages()` → 조건에 따라 설정/해제 포함

- `getHtml()` → HTML 렌더링

"테스트 페이지라면 설정과 해제를 포함해서 HTML을 반환한다" 라는 고수준 행위에 대한 세부적인 작업들의 나열이기 때문에 하나의 추상화로 구분할 수 있는 거라고 합니다.

즉, 하나의 고수준 목표를 위한 세부적인 하위 단계를 의미합니다.

---

## 함수 당 추상화 수준은 하나로!

함수가 확실히 '한 가지' 작업만 하려면 함수 내 모든 문장의 추상화 수준을 동일하게 해야 한다.

- getHtml() -> 추상화 수준 높음
- String pagePathName = PathParser.render(pagePath) -> 추상화 수준 중간
- .append("") -> 추상화 수준 낮음

같은 함수 내에서 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다.

> 이 추상화라는게 어떤식으로 구분되는지 궁금해서 gpt한테 물어봤습니다.

추상화의 수준을 `고수준`과 `저수준`으로 구분하는데,
`고수준`은 **무엇을 하는가**
`저수준`은 **어떻게 하는가**
라고 이야기 합니다.

예시를 보면서 이해해보면,

```js
function sendWelcomeEmail(user) {
  const email = createWelcomeEmail(user);
  sendEmailToUser(user.email, email);
}
```

`sendWelcomeEmail`라는 함수이름은 "이메일에 Welcome을 보낸다"라는 **무엇을 하는가** 에 해당하는 `고수준`추상화 입니다.
그리고 내부에서는 그에 맞는
`createWelcomeEmail`과 `sendEmailToUser`라는 결국 Email로 Welcome이라는 메시지를 send하기위한 일련의 과정을 추상화 해둔 `중간 수준`의 추상화를 제공합니다.

그러면 잘못된 예시도 한 번 봐야겠네요

```js
function sendWelcomeEmail(user) {
  const email = {
    subject: "Welcome!",
    body: `Hello ${user.name}, thanks for signing up!`,
  };
  smtp.send({
    to: user.email,
    subject: email.subject,
    body: email.body,
  });
}
```

동일한 코드인데 뭐가 잘못됐는지 보이시나요?
함수의 이름이 `sendWelcomeEmail`라는 고수준에 `대한하는 **무엇을 하는가**에 대해서 이야기 합니다.
하지만 내부 로직에서는
email에 객체를 직접 할당하거나, smtp로 직접 메일을 보내고 있는 **어떻게 하는가** 에 대한 `저수준`추상화를 제공합니다.

그렇기 때문에 **고수준**의 함수명과 다르게, 내부에서는 **저수준**의 추상화를 제공해 코드를 읽어 내려가는 사람이 읽는데 어려움을 겪을 수 있습니다.

### 위에서 아래로 코드 읽기: *내려가기*규칙

**고수준**에서 **저수준**으로 즉, 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다. 이것을 *내려가기*규칙 이라고 부른다.`

## Switch 문

Switch문은 N가지를 처리한다. 이 이야기는, 한 가지 작업만 하르는 규칙에 위반된다.

- 함수가 길어진다.
- '한 가지' 작업만 수행하지 않는다.
- SRP를 위한반다
- OCP를 위한반다.

> SPR: "모듈은 단 한 명의 행위자에게만 책임을 져야 한다."
> OCP: "개방 - 폐쇄 원칙" "소프트웨어 엔티티(클래스, 모듈, 함수)는 확장을 위해 열려 있어야 하지만 수정을 위해 닫혀 있어야 한다."

글쓴이는 Switch문을 한 번은 참아준다고 한다. 다형성 객체를 생성하는 코드 안에서 만 사용함.

상속 관계로 숨기고, 절대로 다른 코드에 노출시키지 않는다

## 서술적인 이름을 사용하라!

좋은 이름이 주는 가치에 대해서 계속해서 강조한다.
한 가지의 일만 하는 작은 함수에 좋은 이름을 붙인다면, 읽기좋은 코드의 절반을 성공한 것 이다.

이름이 길어도 괜찮다. 함수 이름을 정할 때는 여러 단어가 쉽게 읽히는 명명법을 사용한다.

서술적인 이름을 사용하면, 설계가 뚜렷해져, 코드를 개선하기 쉬워진다.

이름을 붙일 땐, 일관성이 있어야 한다.

- 모듈 내 함수이름은 같은 문구, 명사, 동사를 사용한다.

## 함수 인수

함수에서 이상적인 인수 개수는 `0개`다.
그리고 4개 이상은 특별한 이유가 필요하다.

인수의 개념은, 함수를 이해하기 어렵게 만든다.

테스트 관점에서의 인수는 더 어렵다. 인수의 값이 많아지면, 그에 맞는 유요한 조합을 구성해야 하기 때문에 테스트가 상당히 부담스러워진다.

### 많이 쓰는 단항 형식

- 하나의 인수에 질문을 던지는 경우
  `boolean fileExists("MyFile")`
- 인수를 뭔가로 변환해 결과를 반환하는 경우
  `InputStream fileOpen("MyFile")`

위 내용을 제외하고는 단항 함수는 가급적 피하는 편이 좋다.

> 인수를 적게 쓰는 것이 가독성도 좋아지고, 함수를 이해하는데 방해가 안된다는 걸 알고 있지만, 실제로 코드를 짜보면 인수를 넣지 않고 만드는건 어려운 일인 것 같습니다

### 플래그 인수

플래그는 끔찍하다 말한다.

`render(true)`라는 코드는 IDE의 도움으로, 마우스를 가져갔을 때, `render(boolean isSuite)`라는 정보가 뜨지만, 도움이 되지 않는다.

위 함수는,
`renderForSuite()` 와 `renderForSingleTest()` 로 나눠야한다고 말한다.

> 플래그 인수라는 말을 처음 들어봐서 뭔지 찾아봤는데, 그냥 true와 false값으로 이루어진 boolean 값을 뜻 하는 거였습니다.

```js
let isValidation = false;

if (isValidation) {
  console.log("검증되었습니다.");
} else {
  console.log("검증이 필요합니다");
}
```

위 코드 처럼, 단순하게 사용되는 조건문의 값을 변수로 의미를 부여하는 방식을 `flag변수`라고 하는 것 같습니다.

> 위 내용이 맞다면, 해당 책에서는 플래그 인수는 별로 좋지 않다고 말합니다. 플레그 변수를 사용하는건 상관이 없다는건지는 몰라도, 이러한 플레그 변수를 함수의 인수값으로 넣었을 때에는 함수의 가독성의 문제가 생각다는 것 같습니다.

다시 위 코드를 보면,

`render`함수가 이렇게 생겼다고 가정할 수 있습니다.

```js
function render(isSuite) {
  if (isSuite) {
    //suite용 렌더링
  } else {
    //단일 테스트용 렌더
  }
}
```

책에서 말하는 플레그 인수를 사용한다는 것은, 하나의 함수에서 여러 역할을 수행할 가능성을 이야기 할 수 있습니다. 이는 단일책임원칙을 위반하는 행위 입니다.

또 한, 호출하는 부분에서는 `render(true)`라고 호출하기 때문에, 실제로 들어간 `boolean`값이 어떤식으로 동작하는지 알기가 어렵습니다.

그래서 함수를 쪼개서 렌더링하라고 말하는 것 이고요,

```js
function renderForSuite() {
  //suite용 렌더링
}

function renderForSingleTest() {
  //단일 테스트용 렌더
}
```

이런식으로 구분하는 편이 훨씬 가독성이 좋고, 의미 파악하기 좋다는걸 의미하는 것 같습니다.

> javascript에서 인수를 넘기는 방식중, 객체를 넘기는 방식이 존재합니다.

```ts
function render({ isSuite }: { isSuite: boolean }) {
  if (isSuite) {
  } else {
  }
}
```

해당 코드는 단일책임을 분명 위배하는 것은 맞지만, 나름 코드를 읽는대는 문제가 없다고 생각합니다. 제가 자주 사용하는 기능이기도 하고, react에서는 컴포넌트에 데이터를 넘길 때, 백엔드로부터 받은 데이터를 props로 넘기는 경우가 자주 발생합니다. 그러면 어쩔 수 없이 함수의 인수가 많아지는 꼴인데, 하나의 객체로 감싸서 관리하는 편이 저는 더 좋다고 생각해서 그렇게 사용합니다.

```tsx
function TestComponent({ name, age, weight }: TestComponentProps) {}
```

이렇게 정의된 함수는 다음과 같이 사용됩니다.

```tsx
const personInfo = {
  name: 이재진,
  age: 24,
  weight: 65.4
}

<TestComponent {...personInfo}/>
```

컴포넌트라는 특수한 상황이 있기 때문에 가능한 부분이라고 생각하지만, 이런 부분도 있다 적어보고 싶었습니다.

### 이항 함수

- 인수가 2개인 함수는 인수가 1개인 함수보다 이해하기 어렵다.
- 하지만 이항 함수가 어울리는 경우가 존재한다.
  `point(0, 0)`, `location(0, 0)` 과 같은 함수는, 두 인수가 무엇을 의미하는지, 말하지 않아도 알 수 있다.

이항 함수가 무조건 나쁘다는 것은 아니지만, 가능하면 단항, 혹은 무항으로 바꾸는 노력이 필요하다.

### 삼항 함수

인수가 3개인 함수는 인수가 2개인 함수보다 더 더 이해하기 어렵다.

### 인수 객체

- 인수가 2-3개 필요하다면, 객체를 생성해라,

> 위에서 컴포넌트에 대해서 설명한 내용이 바로 나옵니다.

### 인수 목록

때로는 인수가 가변적인 함수가 필요하다.

```c
String.format("%s worked %.2f" hours.", name, hours);
```

뒤에 붙는 가변 인수를 전부 동등하기 취급하면 List형 인수 하나로 취급이 가능하다.

> 가변인수에 대해서 찾아봤는데, 단순히 호출하는 부분에서 인수의 수가 변하는 것을 의미합니다. 오버로딩과 같은 동작으로 이해할 수 있습니다. 실제로는 여러값을 넘기지만, 하나의 배열 형태로 넘겨야 된다고 이야기합니다. 하지만 이마저도 너무 많아지면 좋지 않다고 합니다.

### 동사와 키워드

함수/인수 가 동사/명사 의 쌍을 이루는게 좋다.

```js
write(name); //이름을 쓴다.
```

```js
writeField(name); //이름이 필드라는 것이 분명하게 드러남
```

키워드를 추가할 수도 있다.

```js
assertEquals(expected, actual);
```

```js
assertExpectedEqualsActual(expected, actual);
```

이렇게 바꾸면, 인수의 순서를 기억할 필요가 없어진다.

## 부수 효과를 일으키지 마라!

```java

public class UserValidator {
  private Cryptographer cryptographer;

  public boolean checkPassword(String userName, String password) {
    User user = UserGateway.findByName(userName);
    if (user != User.NULL) {
      String codedPhrase = user.getPhraseEncodedByPassword();
      String phrase = cryptographer.decrypt(codedPhrase, password);
      if ("Valid Password".equals(phrase)) {
        Session.initialize();
        return true;
      }
    }
    return false;
  }
}
```

위 코드에서 `Session.initialize`는 부수적인 기능이다. 함수 이름만 봤을 때는 User의 password유효성을 검사하기 위한 기능을 수행한다. 그래서 함수 이름만 보고, 해당 함수를 호출했을 때, 세션의 정보를 지워버릴 위험이 존재한다.

"한 가지"만 수행한다는 규칙을 위반하지마 , `checkPasswordAndInitializeSession`이라는 이름이 훨 좋다.

### 출력 인수

함수의 인수를 출력으로 사용하는 것은 어색하다고 느낄 것 이다.
별로 좋지 않다.

## 명령과 조회를 분리하라!

- 함수는 뭔가를 수행하거나, 뭔가를 답하거나 둘 중 하나만 해야한다.

`set("username", "unclebob")`은 독자입장에서 어떤 동작을 하는지 명확하게 의미를 파악하기 어렵다.

조회와 명령을 분리하면 다음과 같이 된다.
`attributeExists("username")`
`setAttribute("username", "unclebob");`

## 오류 코드보다 예외를 사용하라!

오류 코드를 이용해서 조건문 처리를 하는 것 보다, 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리되므로 깔끔해 진다.

### Try/Catch 블록 뽑아내기

`try-catch`문은 추하다, 코드 구조에 혼란을 일으키지 때문에, 별도의 함수로 뽑아내는 편이 좋다.

### 오류 처리도 한 가지 작업이다.

함수는 `한 가지` 작업만 수행한다 에서, 오류도 하나의 작업에 속한다. 그렇기 때문에 오류를 처리하는 함수는 오류만 처링해야 마땅하다.

## 반복하지 마라!

코드길이가 늘어날 뿐 아니라, 알고리즘이 변하면 네 곳 이나 손 봐야 하기 때문에, 한 곳이라도 빠뜨린다면, 오류가 발생할 수 있다.

## 구조적 프로그래밍

"데이크스트라"는 모든 함수와 함수 내 모든 블록에 입구와 출구가 하나만 존재해야 한다고 말한다. 즉 함수는 return문이 하나여야 한다는 의미이다.

루프 안에 break나 continue를 사용해서는 안된다.

하지만 함수가 작아진다면, 위 규칙은 별 이익을 제공하지 못해, 사용해도 괜찮아진다.

## 함수를 어떻게 짜죠?

- 처음에 길고 복잡한 코드를 만들고, 중복된 코드도 많이 만들게 된다.
- 그런 다음에, 코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거한다.
- 위 과정 중간에 코드는 항상 단위 테스트를 통과해야 한다.

## 결론

프로그래밍의 기술은 언제나 언어 설계의 기술이다.

구현할 프로그램이 아니라, 풀어갈 이야기로 여겨야 한다.
