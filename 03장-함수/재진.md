# 감상문

# 03장 함수

---

책에서는 예시 코드가 주어진다.
FtiNesse의 긴 함수를 예시로 들어주는데, 이 코느는 파악하기 힘든 코드의 예시를 보여준다.
그리고 다음으로 구조를 조금 변경한 하나의 다른 함수를 보여준다.

두 코드의 차이는, 메소드를 분리하고, 이름을 명확하게 만들고, 이해하기 쉽도록 함수 내부 코드를 간략화 시켰다.

> 저는 자바를 공부하고 있지도 않고, 얕은 지식으로는 명확한 코드를 파악하기 어려웠습니다. 그럼에도, 3-1에서 보여준 코드와, 3-2에서 보여준 코드가 무엇을 의미하는지 명확하게 알 수 있었습니다.

---

## 작게 만들어라!

- 함수를 만드는 첫 번째 규칙: '작게'
- 두 번째 규칙: '더 작게'

작을수록 좋다는 증거를 제시할 순 없지만, 글쓴이의 경험으로 비춰봤을 때 , 300줄 되는 코드보다는 30줄 되는 코드가 좋다고 한다. 그래서 위에서 설명했던, 3-2 코드를 한 번 더 줄인다.

### 블록과 들여쓰기

if, else, while과 같은 블록은 한 줄이어야 한다고 한다. 보통 그 내부에서는 함수를 호출하기에, 바깥을 감싸는 함수의 길이가 작아질 뿐 아니라, 블록 안에서 호출하는 함수 이름을 적절하게 짓는다면, 코드를 이해아기 더 쉬워진다고 한다.

다른 말로는, 함수가 중첩 구조가 생길 만큼 커져서는 안된다고도 설명한다.

> 여기서는 하나의 함수 로직이 3 4줄 정도로 끝나야 한다고 말하지만, 현실에서는 그정도로 함수를 작게 만드는건 굉장히 어려운 것 같습니다. 처음부터 작게 만들어야지 하는게 아니라, 점진적으로 리팩터링을 통해서 작게 만드는 노력을 해야할 것 같습니다.

---

## 한 가지만 해라!

> 함수는 한 가지를 해야 한다. 그 한가지를 잘 해야 한다. 그 한가지만을 해야한다.

```java
public static String renderPageWithSetupsAndTeardowns(
 PageData pageData, boolean isSuite) throws Exception {
 if (isTestPage(pageData))
 includeSetupAndTeardownPages(pageData, isSuite);
 return pageData.getHtml();
}
```

해당 코드가 한 자기만 하는가?

1. 페이지가 테스트 페이지인지 판단한다.
2. 그렇다면 설정 페이지와 해제 페이지를 넣는다.
3. 페이지를 HTML로 렌더링 한다.

이렇게 되면 한 가지가 아닌게 아닌가?
위에서 언급한 세 단계는 지정된 함수 이름 아래에서 추상화 수준이 하나다.

> 페이지가 테스트 페이지인지 확인한 후 테스트 페이지라면 설정 페이지와 해제 페이지를 넣는다. 테스트 페이지든 아니든 페이지를 HTML로 렌더링 한다.

지정된 함수 이름 아래에 추상화 수준이 하나인 단계만 수행한다.

> 위 내용에 대해서 어째서 하나의 추상화로 동작하는지 이해가 잘 안돼서 gpt한테 부탁하니 이런 답을 내주었습니다.

- `isTestPage()` → 판단

- `includeSetupAndTeardownPages()` → 조건에 따라 설정/해제 포함

- `getHtml()` → HTML 렌더링

"테스트 페이지라면 설정과 해제를 포함해서 HTML을 반환한다" 라는 고수준 행위에 대한 세부적인 작업들의 나열이기 때문에 하나의 추상화로 구분할 수 있는 거라고 합니다.

즉, 하나의 고수준 목표를 위한 세부적인 하위 단계를 의미합니다.

---

## 함수 당 추상화 수준은 하나로!

함수가 확실히 '한 가지' 작업만 하려면 함수 내 모든 문장의 추상화 수준을 동일하게 해야 한다.

- getHtml() -> 추상화 수준 높음
- String pagePathName = PathParser.render(pagePath) -> 추상화 수준 중간
- .append("") -> 추상화 수준 낮음

같은 함수 내에서 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다.

> 이 추상화라는게 어떤식으로 구분되는지 궁금해서 gpt한테 물어봤습니다.

추상화의 수준을 `고수준`과 `저수준`으로 구분하는데,
`고수준`은 **무엇을 하는가**
`저수준`은 **어떻게 하는가**
라고 이야기 합니다.

예시를 보면서 이해해보면,

```js
function sendWelcomeEmail(user) {
  const email = createWelcomeEmail(user);
  sendEmailToUser(user.email, email);
}
```

`sendWelcomeEmail`라는 함수이름은 "이메일에 Welcome을 보낸다"라는 **무엇을 하는가** 에 해당하는 `고수준`추상화 입니다.
그리고 내부에서는 그에 맞는
`createWelcomeEmail`과 `sendEmailToUser`라는 결국 Email로 Welcome이라는 메시지를 send하기위한 일련의 과정을 추상화 해둔 `중간 수준`의 추상화를 제공합니다.

그러면 잘못된 예시도 한 번 봐야겠네요

```js
function sendWelcomeEmail(user) {
  const email = {
    subject: "Welcome!",
    body: `Hello ${user.name}, thanks for signing up!`,
  };
  smtp.send({
    to: user.email,
    subject: email.subject,
    body: email.body,
  });
}
```

동일한 코드인데 뭐가 잘못됐는지 보이시나요?
함수의 이름이 `sendWelcomeEmail`라는 고수준에 `대한하는 **무엇을 하는가**에 대해서 이야기 합니다.
하지만 내부 로직에서는
email에 객체를 직접 할당하거나, smtp로 직접 메일을 보내고 있는 **어떻게 하는가** 에 대한 `저수준`추상화를 제공합니다.

그렇기 때문에 **고수준**의 함수명과 다르게, 내부에서는 **저수준**의 추상화를 제공해 코드를 읽어 내려가는 사람이 읽는데 어려움을 겪을 수 있습니다.

### 위에서 아래로 코드 읽기: *내려가기*규칙

**고수준**에서 **저수준**으로 즉, 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다. 이것을 *내려가기*규칙 이라고 부른다.`

## Switch 문

Switch문은 N가지를 처리한다. 이 이야기는, 한 가지 작업만 하르는 규칙에 위반된다.

- 함수가 길어진다.
- '한 가지' 작업만 수행하지 않는다.
- SRP를 위한반다
- OCP를 위한반다.

> SPR: "모듈은 단 한 명의 행위자에게만 책임을 져야 한다."
> OCP: "개방 - 폐쇄 원칙" "소프트웨어 엔티티(클래스, 모듈, 함수)는 확장을 위해 열려 있어야 하지만 수정을 위해 닫혀 있어야 한다."

글쓴이는 Switch문을 한 번은 참아준다고 한다. 다형성 객체를 생성하는 코드 안에서 만 사용함.

상속 관계로 숨기고, 절대로 다른 코드에 노출시키지 않는다

## 서술적인 이름을 사용하라!

좋은 이름이 주는 가치에 대해서 계속해서 강조한다.
한 가지의 일만 하는 작은 함수에 좋은 이름을 붙인다면, 읽기좋은 코드의 절반을 성공한 것 이다.

이름이 길어도 괜찮다. 함수 이름을 정할 때는 여러 단어가 쉽게 읽히는 명명법을 사용한다.

서술적인 이름을 사용하면, 설계가 뚜렷해져, 코드를 개선하기 쉬워진다.

이름을 붙일 땐, 일관성이 있어야 한다.

- 모듈 내 함수이름은 같은 문구, 명사, 동사를 사용한다.

## 함수 인수

함수에서 이상적인 인수 개수는 `0개`다.
그리고 4개 이상은 특별한 이유가 필요하다.

인수의 개념은, 함수를 이해하기 어렵게 만든다.

테스트 관점에서의 인수는 더 어렵다. 인수의 값이 많아지면, 그에 맞는 유요한 조합을 구성해야 하기 때문에 테스트가 상당히 부담스러워진다.

### 많이 쓰는 단항 형식

- 하나의 인수에 질문을 던지는 경우
  `boolean fileExists("MyFile")`
- 인수를 뭔가로 변환해 결과를 반환하는 경우
  `InputStream fileOpen("MyFile")`

위 내용을 제외하고는 단항 함수는 가급적 피하는 편이 좋다.

> 인수를 적게 쓰는 것이 가독성도 좋아지고, 함수를 이해하는데 방해가 안된다는 걸 알고 있지만, 실제로 코드를 짜보면 인수를 넣지 않고 만드는건 어려운 일인 것 같습니다

### 플래그 인수

플래그는 끔찍하다 말한다.

`render(true)`라는 코드는 IDE의 도움으로, 마우스를 가져갔을 때, `render(boolean isSuite)`라는 정보가 뜨지만, 도움이 되지 않는다.

위 함수는,
`renderForSuite()` 와 `renderForSingleTest()` 로 나눠야한다고 말한다.

> 플래그 인수라는 말을 처음 들어봐서 뭔지 찾아봤는데, 그냥 true와 false값으로 이루어진 boolean 값을 뜻 하는 거였습니다.

```js
let isValidation = false;

if (isValidation) {
  console.log("검증되었습니다.");
} else {
  console.log("검증이 필요합니다");
}
```

위 코드 처럼, 단순하게 사용되는 조건문의 값을 변수로 의미를 부여하는 방식을 `flag변수`라고 하는 것 같습니다.

> 위 내용이 맞다면, 해당 책에서는 플래그 인수는 별로 좋지 않다고 말합니다. 플레그 변수를 사용하는건 상관이 없다는건지는 몰라도, 이러한 플레그 변수를 함수의 인수값으로 넣었을 때에는 함수의 가독성의 문제가 생각다는 것 같습니다.

다시 위 코드를 보면,

`render`함수가 이렇게 생겼다고 가정할 수 있습니다.

```js
function render(isSuite) {
  if (isSuite) {
    //suite용 렌더링
  } else {
    //단일 테스트용 렌더
  }
}
```

책에서 말하는 플레그 인수를 사용한다는 것은, 하나의 함수에서 여러 역할을 수행할 가능성을 이야기 할 수 있습니다. 이는 단일책임원칙을 위반하는 행위 입니다.

또 한, 호출하는 부분에서는 `render(true)`라고 호출하기 때문에, 실제로 들어간 `boolean`값이 어떤식으로 동작하는지 알기가 어렵습니다.

그래서 함수를 쪼개서 렌더링하라고 말하는 것 이고요,

```js
function renderForSuite() {
  //suite용 렌더링
}

function renderForSingleTest() {
  //단일 테스트용 렌더
}
```

이런식으로 구분하는 편이 훨씬 가독성이 좋고, 의미 파악하기 좋다는걸 의미하는 것 같습니다.

> javascript에서 인수를 넘기는 방식중, 객체를 넘기는 방식이 존재합니다.

```ts
function render({ isSuite }: { isSuite: boolean }) {
  if (isSuite) {
  } else {
  }
}
```

해당 코드는 단일책임을 분명 위배하는 것은 맞지만, 나름 코드를 읽는대는 문제가 없다고 생각합니다. 제가 자주 사용하는 기능이기도 하고, react에서는 컴포넌트에 데이터를 넘길 때, 백엔드로부터 받은 데이터를 props로 넘기는 경우가 자주 발생합니다. 그러면 어쩔 수 없이 함수의 인수가 많아지는 꼴인데, 하나의 객체로 감싸서 관리하는 편이 저는 더 좋다고 생각해서 그렇게 사용합니다.

```tsx
function TestComponent({ name, age, weight }: TestComponentProps) {}
```

이렇게 정의된 함수는 다음과 같이 사용됩니다.

```tsx
const personInfo = {
  name: 이재진,
  age: 24,
  weight: 65.4
}

<TestComponent {...personInfo}/>
```

컴포넌트라는 특수한 상황이 있기 때문에 가능한 부분이라고 생각하지만, 이런 부분도 있다 적어보고 싶었습니다.

### 이항 함수

- 인수가 2개인 함수는 인수가 1개인 함수보다 이해하기 어렵다.
- 하지만 이항 함수가 어울리는 경우가 존재한다.
  `point(0, 0)`, `location(0, 0)` 과 같은 함수는, 두 인수가 무엇을 의미하는지, 말하지 않아도 알 수 있다.

이항 함수가 무조건 나쁘다는 것은 아니지만, 가능하면 단항, 혹은 무항으로 바꾸는 노력이 필요하다.

### 삼항 함수

인수가 3개인 함수는 인수가 2개인 함수보다 더 더 이해하기 어렵다.

### 인수 객체

- 인수가 2-3개 필요하다면, 객체를 생성해라,

> 위에서 컴포넌트에 대해서 설명한 내용이 바로 나옵니다.

### 인수 목록

때로는 인수가 가변적인 함수가 필요하다.

```c
String.format("%s worked %.2f" hours.", name, hours);
```

뒤에 붙는 가변 인수를 전부 동등하기 취급하면 List형 인수 하나로 취급이 가능하다.

> 가변인수에 대해서 찾아봤는데, 단순히 호출하는 부분에서 인수의 수가 변하는 것을 의미합니다. 오버로딩과 같은 동작으로 이해할 수 있습니다. 실제로는 여러값을 넘기지만, 하나의 배열 형태로 넘겨야 된다고 이야기합니다. 하지만 이마저도 너무 많아지면 좋지 않다고 합니다.

### 동사와 키워드

함수/인수 가 동사/명사 의 쌍을 이루는게 좋다.

```js
write(name); //이름을 쓴다.
```

```js
writeField(name); //이름이 필드라는 것이 분명하게 드러남
```

키워드를 추가할 수도 있다.

```js
assertEquals(expected, actual);
```

```js
assertExpectedEqualsActual(expected, actual);
```

이렇게 바꾸면, 인수의 순서를 기억할 필요가 없어진다.
