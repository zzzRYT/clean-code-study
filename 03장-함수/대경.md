# ⭐ 감상문

## 3장 함수

> 앞 장들보다 내용도 예제도 꽤 어려웠던 파트였다. 하지만 공감되고 실무적으로 배웠던 부분도 많았다.

### 작게 만들어라!

- 예제1

```ts
public static testableHtml(pageData: PageData, includeSuiteSetup: boolean): string {
  const wikiPage = pageData.getWikiPage();
  const buffer = new StringBuffer();

  if (pageData.hasAttribute('Test')) {
    if (includeSuiteSetup) {
      const suiteSetup = PageCrawlerImpl.getInheritedPage(SuiteResponder.SUITE_SETUP_NAME, wikiPage);
      if (suiteSetup !== null) {
        const pagePath = suiteSetup.getCrawler().getFullPath(suiteSetup);
        const pagePathName = PathParser.render(pagePath);
        buffer.append('!include -setup .')
              .append(pagePathName)
              .append('\n');
      }
    }

    const setup = PageCrawlerImpl.getInheritedPage('Setup', wikiPage);
    if (setup !== null) {
      const setupPath = wikiPage.getCrawler().getFullPath(setup);
      const setupPathName = PathParser.render(setupPath);
      buffer.append('!include -setup .')
            .append(setupPathName)
            .append('\n');
    }
  }

  buffer.append(pageData.getContent());

  if (pageData.hasAttribute('Test')) {
    const teardown = PageCrawlerImpl.getInheritedPage('TearDown', wikiPage);
    if (teardown !== null) {
      const tearDownPath = wikiPage.getCrawler().getFullPath(teardown);
      const tearDownPathName = PathParser.render(tearDownPath);
      buffer.append('\n')
            .append('!include -teardown .')
            .append(tearDownPathName)
            .append('\n');
    }

    if (includeSuiteSetup) {
      const suiteTeardown = PageCrawlerImpl.getInheritedPage(SuiteResponder.SUITE_TEARDOWN_NAME, wikiPage);
      if (suiteTeardown !== null) {
        const pagePath = suiteTeardown.getCrawler().getFullPath(suiteTeardown);
        const pagePathName = PathParser.render(pagePath);
        buffer.append('!include -teardown .')
              .append(pagePathName)
              .append('\n');
      }
    }
  }

  pageData.setContent(buffer.toString());
  return pageData.getHtml();
}
```

- 예제2 : 예제1 변경

```ts
 public static renderPageWithSetupsAndTeardowns(pageData: PageData, isSuite: boolean): string {
  const isTestPage = pageData.hasAttribute('Test');

  if (isTestPage) {
    const testPage = pageData.getWikiPage();
    const newPageContent = new StringBuffer();

    this.includeSetupPages(testPage, newPageContent, isSuite);
    newPageContent.append(pageData.getContent());
    this.includeTeardownPages(testPage, newPageContent, isSuite);

    pageData.setContent(newPageContent.toString());
  }

  return pageData.getHtml();
}
```

- 예제3

```ts
public static renderPageWithSetupsAndTeardowns(pageData: PageData, isSuite: boolean): string {
  if (this.isTestPage(pageData)) {
    this.includeSetupAndTeardownPages(pageData, isSuite);
  }
  return pageData.getHtml();
}
```

- 함수를 만드는 첫째 규칙은 '작게!'다. 함수를 만드는 둘째 규칙은 '더 작게!'다.
- 함수의 길이는 예제2 보다 짧아야 한다. 예제2도 예제3으로 줄어야 마땅하다.

### 블록과 들여쓰기

- if문 while문 등에 들어가는 블록은 한줄이어야 한다는 의미다. 대게 거기서 함수를 호출한다.
- 바깥을 감싸는 함수(enclosing function)가 작아질 뿐 아니라, 블록 안에서 호출하는 함수 이름을 적절히 짓는다면, 코드를 이해하기도 쉬워진다.
- 중첩 구조가 생길 만큼 함수가 커져서는 안 된다는 뜻이다. 함수에서 들여쓰기 수준이 1단 2단을 넘어서면 안된다.

### 한 가지만 해라!

- 예제 1은 여러가지를 처리한다. 예제 3은 한 가지만 처리한다.
- 함수는 한가지를 해야한다. 그 한 가지를 잘 해야한다. 그 한 가지만을 해야한다.
- 예제 3은 여러가지를 하는것처럼 볼 수 있으나. 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한가지 작업만 한다.

> 이 부분이 다들 어떻게 느낄지 모르겠는데, 나 한테는 어려운 부분이었다. 함수가 한가지 일을 잘 해야하는걸 알겠고, 함수 안의 함수들이 추상화 수준이 같으면 그함수가 한가지 작업만 한다는걸 알겠다.
> 실제로 구현을 할때는 이 라이브러리 객체, 메서드들이 같은 추상화 레벨일지 아닐지 많이 고민하게 될 것 같다.
> 이 문단의 함수를 한가지만 하는 판단의 설명이 잘 와닫지 않아서 한번의 독서로 글쓴이의 생각을 읽기 힘들었다.

- 함수가 한가지만 하는지 판단하는 방법이 하나 더 있다. 의미있는 이름으로 다른 함수를 추출 할 수 있다면 그함수는 여러 작업을 하는 셈이다.

> 추상화 수준이 같아야한다는 위의 방법이 더 구체적이지만. 나는 이 방법 더 공감 되었다.

#### 함수 내 섹션

- 한가지만 작업하는 함수는 자연스럽게 어러 섹션으로 나누기 어렵다.

### 함수 당 추상화 수준은 하나로!

- 함수가 확실히 한가지 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일 해야한다.

#### 위에서 아래로 코드 읽기: 내려가기 규칙

- 코드는 위에서 아래로 이야기처럼 읽혀야 좋다.
- 한 함수 다음에는 추상화 수준이 한단계 낮은 함수가 온다. 즉 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한번에 한 단계 씩 낮아진다.
- 내려가기 규칙
- 일련의 TO 문단을 읽듯이 프로그램이 읽혀야 한다.

> TO 문단 처음에는 뭐지 했는데. 평소 프로그래밍 할때 글로 작성하던 그 생각의 로직이더라.
> 유저들에게 아이템 구매를 시키기 위해 1. 어떤 아이템을 살지 목록을 받는다. 2. 목록을 보고 데이터를 가져온다... 이런 일련의 과정을 쓰던걸 to 문단 이라고 하는거 같다.

- 추상화 수준이 하나인 함수를 구현하기란 쉽지 않다. 그렇지만 매우 중요한 규칙이다. TO 문단을 읽어내려 가듯이 코드를 구현하면 추상화 수준을 일관되게 유지하기가 쉬워진다.

> 위에서 이해안되던 같은 레벨의 추상화 단계를 나에게 좀 더 이해시키는 문단이었다. 적어도 이런식으로 작성하면 되겠구나는 느꼈다.

### Switch 문

- switch문은 작게 만들기 어렵다.
- 본질 적으로 swhitch문은 여러가지를 처리한다.
- 다형성을 이용하자

> 이곳에 작성하지는 않았지만 스위치 예제문을 설명할때 "가장 심각한 문제라면 위 함수 구조가 동일한 함수가 무한정 존재한다"
> 라는 부분이 와닫지 않았다. 직감적으로 스위치문을 늘려나갈 수 있다 정도로만 이해했다.
> 스위치문을 다형성 객체를 생성하는 팩토리패턴으로 구현한건 인상적이었다. 스위치문을 잘 변경했다고 생각한다. 나는 오히려 어려웠던 부분이 이 스위치 문을 아예 없애는
> 다형성 코드들에 익숙해져서 왜 같은 다형성 코드인데 스위치문을 그대로 사용하게 되었던 걸까 하고 흐름을 비교해 보는것이 훨씬 어려웠다.
> 위 내용이 이해하기 어렵다 생각해서 간단히 말하면 예제의 코드와 <https://www.youtube.com/shorts/lK3ZyTt0yNo> 링크의 유튜브를 비교해보면서 왜 스위치문이 사라지지
> 않았을까 고민해봤다.

- 일반적으로 나는 Switch문을 단 한번만 참아준다. 다형적 객체를 생성하는 코드에서다.

### 서술적인 이름을 사용하라!

- 코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다.
- 함수가 작고 단순할수록 서술적인 이름을 고르기도 쉬워진다.
- 이름을 붙일 때는 일관성이 있어야 한다. 모듈내에서 함수 이름은 같은 문구, 명사, 동사를 사용한다.

### 함수 인수

- 함수에서 이상적인 인수 개수는 0개다. 그 다음은 1개고 다음은 2개다. 3개는 피하는 편이 좋다.
- 인수는 개념을 이해하기 어렵게 만든다.
- 테스트 관점에서보면 인수는 더 어렵다. 갖가지 인수 조합으로 함수를 검증하는 테스트 케이스를 작성하는건 어렵다.
- 출력인수는 입력인수 보다 이해하기 어렵다. 우리는 함수에 인수로 입력을 넘기고 반환값으로 출력을 받는 개념에 익숙하지만 대개 함수에서 인수로 결과를 받으리라 기대하지 않는다.
- 최선은 입력 인수가 없는 경우이며, 차선은 입력 인수가 1개 뿐인 경우다.

> 예전에 클린코드를 비판하는 내용중에 함수를 코드 감싸기로만 생각한다는 이야기를 들은적이 있다. 이부분을 읽으면서 그게 생각났다.
> 나 스스로 이 부분을 읽다보니. 아마 글쓴이는 특정 객체가 나온다고 암시적으로 정해진 디자인패턴 메서드를 설명하기 보다는 진짜로 코드 추상화 목적의 함수를 구현할때
> 인수가 없어야한다는 취지로 이야기를 한게 아닌가 생각이 들었다.

#### 많이 쓰는 단항 형식

- 인수 1개를 넘기는 이유로 가장 흔한 경우는 두가지다. 인수에 질문을 던지는 경우. 인수를 뭔가로 변환해 결과를 반환하는 경우.
- 함수 이름을 지을 때는 두 경우를 분명히 구분한다. 또한 언제나 일관적인 방식으로 두 형식을 사용한다.

> 입력인수 출력인수 등 잘 사용하지 않던 용어들이 혼란스러웠는데, 해석하니 명료한 느낌이다. 함수에 인수로 넘긴 값을 변환하지 말하는 의미라고 생각한다.
> 결과는 반환값으로 돌려주는것 이다.

#### 플래그 인수

- 플레그 인수는 추하다. 함수가 여러가지를 처리한다고 대놓고 공표하는 셈이니까!

> 가끔 강의 예제에서 보던 패턴인데, 글쓴이가 싫어한다는게 재밌었다.

#### 이항 함수

- 인수가 2개인 함수는 인수가 1개인 함수 보다 이해하기 어렵다.

> 이곳에는 안적었지만, 설명 중 인수가 2개인 예시에서 첫인수를 무시해야한다는 문장을 이해하기 어려웠다.
> gpt와 이야기해보니 이름을 바꾸는 함수에서 바꿀 이름 말고도 단순 정해진 값, 객체등을 인수로 넘기는걸 말했다. 그래서 그 인수가 해야하는 일에서 중요한건 아니고 그냥 필요해서 넘긴다는것이다.
> 이부분이 나는 많이 동감되었다. 나도 트랜젝션등을 구현하기위해 필요한 객체를 단순히 인자로 넘기던 경험이 많았다. 그리고 이 객체를 판단하기 꽤 어렵다고 생각했다. 이 문단에서 해당 경험을 상기시켜 주어서 좋았다.
> 인자의 무시가 익숙해지는 코드는 오류가 숨어든다는 부분도 인상깊었다. 인자 하나에도 많은 생각을 해볼것 같다.

- 이항 함수가 적절한 경우도 있다. Point(0,0). 하지만 여기서 인수 2개는 한 값을 표현하는 두 요소다.
- 이항 함수가 무조껀 나쁜건 아니지만 그만큼 위험이 따른다는 사실을 이해하고 가능하면 단항 함수로 바꾸도록 애써야 한다.

#### 삼항 함수

- 훨씬더 이해하기 어렵다. 순서 주춤 무시로 야기되는 문제가 2배 이상 늘어난다.

#### 인수 객체

- 인수가 여러개 필요하다면 일부를 독자적 클래스 변수로 선언할 가능성을 짚어본다.
- 눈속임이 아니다. 결국은 개념을 표현하게 된다.

> 여러개의 인자대신 하나의 객체를 보내는건 익숙한 문법이다. 나도 이런 형식을 좋아해서 공감되는 부분이었다.
> 특히 ts, js는 객체생성이 자바보다는 자유롭다보니 특히 많이 쓰는 형식인거 같다.

#### 인수 목록

> 잘 이해가 안된다. 다른 분들이 생각을 들어보고 싶다.

#### 동사와 키워드

- 함수의 의도, 인수의 순서, 인수의 의도를 제대로 표현하려면 좋은 함수이름이 필수다.
- 단항 함후는 함수와 인수가 동사/명사 쌍을 이뤄야 한다.
- 함수 이름에 인수 이름을 넣는다. 이러면 인수 순서를 기억할 필요가 없어진다.

> 이 부분은 나는 다를 수 도 있다고 생각한다. 요즘은 IDE나 js경우 JSDoc등을 이용하면 간단하게 인수 순서를
> 보여 줄 수 있다. 내 생각에는 인수가 함수 역할에 특별한 개념,역할이 아니라면 순서만을 위해 함수 이름에 인수들이 모두 들어갈 필요는 없다고 생각한다.
> 이건 경험적으로 함수이름이 지나치게 길어져서이다.
> 다시 생각해보면 이런 경혐은 내가 2개 이상의 인수들을 사용하다보니 생긴 경험이 아닌가 되돌아 본다. 여러 인수를 하나의 개념이 담긴 객체로 묶어서 보내는것에 익숙해지면
> 자연스럽게 함수 이름에 인수를 넣어도 함수명이 많이 길어지지 않을것 같다.

### 부수 효과를 일으키지 마라!

- 부수 효과는 거짓말이다. 함수에서 한가지를 하는게 아니라 다른것도 하는거다.
- 부수 효과가 시간적인 결합을 초래한다. 즉 checkPassword 함수는 특정 상황에서만, 세션을 초기화 해도 괜찮은 경우에만 호출이 가능하다.

> 이곳의 예제에서 일으키는 부수효과는 "비밀번호 확인"함수 에서 조건에 따라 세션을 초기화하는 동작을 하는것이다.
> 생각보다 이런 현상이 꽤나 흔하다고 생각했다. 충분히 내 코드들이나 학교예제에서도 보기 쉬울것 같다고 생각난다.
> 이를 해결할려면 checkPassword 함수와 같은 추상화 레벨에서 세션 초기화를 해야한다.
> 생각보다 많은 깨닫음을 얻은 코드였다. 이 에제는 특히 잘 생각해 봐야겠다.

#### 출력 인수

- 일반적으로 우리는 인수를 함수 입력으로 해석한다.
- 인수를 출력의 목적으로 쓰지 않는다.

> 예를들어 appendFooter(s) 의 s는 입력일까? 선언을 찾아보면 s에 바닥글을 추가하는 함수 이다. 함수 선언을 찾아보고나서야 알았다.
> 이런 행위는 피해야한다.

- 객체 지향 언어에서는 출력 인수를 사용할 필요가 거의 없다. this를 쓰면 되기 때문이다. 함수에서 상태를 변경해야한다면 함수가 속한 객체의 상태를 변경하는 방식을 택한다.

> appendFooter(report) 형식으로 report의 상태를 변경하지 말고 report.appendFooter() 형식으로 report의 상태를 변경하자

### 명령과 조회를 분리하라!

- 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야한다.
- 객체 상태를 변경하거나, 객체 정보를 반환하거나 둘 중 하나다. 둘 다 하면 혼란을 초래한다.

### 오류 코드보다 예외를 사용하라

- 명령 함수가 오류코드를 반환하는 방식은 명령/조회 분리 규칙을 미묘하게 위반한다.
- 오류 코드 대신 예외를 사용하면 오류처리 코드가 원래 코드에서 분리되서 깔끔해진다.

#### Try/Catch 블록 뽑아내기

- Try/Catch 블록은 원래 추하다. 코드 구조에 혼란을 일으키며 정상 동작과 오류 처리 동작을 뒤섞는다.
- Try/Catch 블록을 별도 함수로 뽑아내는 편이 좋다.

> 예외를 사용하라고 위에서 말하고 Try/Catch 는 추하다고 말한게 재미있었다. 그렇다고 이상하진 않고 읽어보면 자연스럽게 이해가 된다.
> 핵심은 위에 에러를 반환해 if를 돌리지말고 캐치문으로 예외를 처리하는게 구조적이고
> Try/Catch도 하나의 역할로만 생각하고 추상화 시키라는거다.

이거 생각보다 많이 좋았는데, 나도 복잡한 Try/Catch를 어떻게 처리할까 고민해봤기 때문이다. 에러 캐치 자체를 추상화하는건 좋은 방법이라고 생각된다.

#### 오류 처리도 한 가지 작업이다.

- 오류처리도 한가지 작업이다. 오류를 처리하는 함수는 오류만 처리해야 마땅하다.

#### Error.java 의존성 자석

- 오류 코드를 반환한다는 이야기는 어디선가 오류코드를 정의한다는 뜻이다.
- 오류 클래스는 의존성 자석이다. 다른 클래스 들에서도 import해 사용해야 하므로 오류객체가 변한다면 모든 클래스 전부를 다시 컴파일하고 배치 해야한다. 그래서 에러 클래스를 변경이 어려워진다.
- 프로그래머는 재컴파일. 재배치가 번거롭기에 새 오류코드를 정의하고 싶지 않다. 그래서 새 오류코드를 추가하는 대신 기존 오류 코드를 재 사용한다.

> 이 부분을 잘 와닫지는 않았다. 특정 클래스 의존이 강해진다는건 이해하지만. nest 사용 입장에서는 에러 객체 생성시 처리하는 부분이 따로 존재하다보니 의존성 문제가
> 잘 와닫지 않는다. 다른 분들의 이야기를 들어보고 싶다.

### 반복하지 마라!

- 코드의 중복을 없애라
- oop를 사용한다면 부모클래스로 몰아 중복을 없앤다.

### 구조적 프로그래밍

- 에츠허르 데이크스트라의 구조적 프로그래밍 원칙은 모든 함수와 함수 내 모든 블록에 입궇와 출구가 하나씩 존재하는 것
- 루프안의 break나 continue를 안쓰기. goto문은 절대로 절대로 안되기
- 목표는 공감하지만 함수가 작으면 위 규칙이 별 이익을 제공하지 못한다. 그러므로 간혹 여러차례 return, break, continue를 사용할 수도 있다.

### 함수를 어떻게 짜죠?

- 소프트웨어를 짜는 행위는 글짓가와 비슷하다. 먼저 생각을기록한 후 읽기 좋게 다듬는다.
- 코드를 다듬고, 함수를 만들고 이름을 바꾸고, 중복을 제거하고, 떄로는 클래스를 쪼개기도 한다.
- 그 와중에 코드는 항상 단위 테스트를 통과한다.
- 결과적으로 이 장에서 설명한 규칙을 따르는 함수가 얻어진다.

### 결론

- 모든 시스템은 특정 응용 분야 시스템을 기술할 ㅁ곡적으로 프로그래머가 설계한 도메인특화 언어로 만들어진다.
- 함수는 동사, 클래스는 명사다. 옛 규칙으로 역행하자는게 아니라 오래된 진실을 말한다.
- 이 장에서는 함수를 잘 만드는 기교를 소개한다. 규칙을 따른다면 좋은 함수가 나올꺼다.
- 하지만 진짜 목표는 시스템이라는 이야기를 풀어가는데에 있다는 사실을 명심해야한다.
