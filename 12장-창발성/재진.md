# 12장 창발성

## 창발적 설계로 깔끔한 코드를 구현하자

네 가지 규칙을 따르면 우수한 설계가 나올 수 있다.

- 모든 테스트를 실행한다.
- 중복을 없앤다.
- 프로그래머 의도를 표현한다.
- 클래스와 메서드 수를 최소로 줄인다.

> 창발성 이란 무엇일까? 창발성의 의미에 대해서 찾아봤습니다.

- 창발성이라는 복잡한 시스템이나 구조에서 개별 구성 요소들이 단순한 규칙에 따라 상호작용하면서, 전체적으로 예측하기 어려운 새로운 특성이나 행동이 나타나는 현상을 이야기 한다고 합니다.

즉, 하위 개념에서 없는 특성이나 행동이, 상위 구조에서 자발적으로 나타나는 현상이라고 합니다.

GPT는 다음과 같이 설명합니다.

> 개미 한 마리 한 마리는 단순한 행동만 하지만, 전체 개미 군락은 복잡한 구조의 집을 짓고 효율적인 식량 수집을 해내는 것에 비유합니다.

즉, 단순한 코드 원칙을 잘 지키면 자연스럽게 잘 설계된 구조로 발전할 수 있다는 뜻입니다.

## 단순한 설계 규칙 1: 모든 테스트를 실행하라

- 테스트가 불가능한 시스템은 검증도 불가능하다.

테스트가 가능한 시스템을 만들려고 애쓰면 설계 품질이 더불어 높아진다. 크기가 작고 목적 하나만 수행하는 클래스가 나온다.

> 결합도가 높으면 테스트 케이스를 작성하기 어렵다.

- 테스트 케이이스를 많이 작성할수록 개발자는 DIP와 같은 원칙을 적용하고
- 의존성 주입(DI),
- 인터페이스
- 추상화
  등과 같은 도구를 사용해 결합도를 낮춘다. 따라서 설계 품질이 더욱 높아진다.

"테스트 케이스를 만들고 계속 돌려라"라는 간단하고 단순한 규칙을 따르면 시스템은 낮은 결합도와 높은 응집력이라는, 객체 지향 방법론이 지향하는 목표를 저절로 달성한다.

> 이 부분을 함수형 프로그래밍 관점에서 어떤식으로 해석하면 좋을까? 라는 고민을 좀 해봤습니다.

얼마전 유튜브에서 토스 모닥불영상을 시청한적이 있습니다. 거기서 함수형 프로그래밍의 핵심은, 순수함수와 side-effect를 줄이는게 좋은 코드라고 이야기 합니다.

- 여기서 순수함수는, 동일한 입력에 대해 항상 같은 결과를 도출하는 함수를 이야기 하며,
- side effect는 외부 상태를 변경하거나, 외부 상태의 의존해 변화하는 것을 의미합니다. 예를들어 상태를 변경하는 함수가 대표적인 side Effect를 발생시키는 요인이죠 그런 의미에서

"테스트를 실행하라"라는 것 또한 함수형 프로그래밍에서 동일한 의미를 가집니다. 테스트가 쉬워진다는 것은 순수함수에 가까워지는 것 이고, side-effect 발생이 적어진다는 의미이기 때문에, 좋은 설계에 근접할 수 있다고 생각합니다.

## 단순한 설계 규칙 2~4: 리팩터링

점진적인 리팩터링을 수행한다.

- 새로 추가하는 코드가 설계 품질은 낮춘다?

그러면 깔끔하게 정리한 후 테스트 케이스를 돌려 기존 기능을 깨뜨리지 않았다는 사실을 확인한다.

> 코드르 정리하면서 시스템이 깨질까 걱정할 필요가 없다. 테스트 케이스가 있으니까!

리팩터링 단계에서는 어떤것을 적용해도 괜찮다.

- 응집도 높이기
- 결합도 낮추기
- 관심사 분리
- 시스템 관심사를 모듈로 나누기
- 함수과 클래스 크리 줄이기
- 더 좋은 이름으로 바꾸기
- 중복 제거하기
- 프로그래머의 의도 표현하기
- 메서드 수 최소로 줄이기

> 테스트를 명확하게 작성했다면, 두려워 말고 리팩터링을 해라 이런 의미로 들렸습니다. 많은 개발자들이 리팩터링을 두려워하는 이유중 하나가, 기존에 잘 돌아가던 시스템이 망가질까봐 걱정하는 부분도 적지 않다고 생각합니다. (물론 저는 만든 로직이 아까워서 못 버리는 것도 있음). 해당 부분에서는 그런 걱정을 버리고, 리팩터링 해라라고 이야기 하는 것 같습니다.

## 중복을 없애라

우수한 설계에서 중복은 커다란 적이다.

깔끔한 시스템을 만들려면 단 몇 줄이라도 중복을 제거해야하는 의지가 필요하다.
예시를 주는데, 설명해보자면,

- scaleToOneDimension 메서드와 rotate 메서드의 일부 코드가 동일하다.
- 해당 코드에서 중복을 제거해보면, 클래스가 SRP를 위한반 사실이 보인다.
- 그러므로 새로 만든 replaceImage메서드를 다른 클래스로 옮기는 시도를 한다. 그러면 새 메서드의 가시성이 높아진다.
- 이렇게 되면 다른 팀원이 새 메서드를 좀 더 추상화해 다른 맥락에서 재사용할 기회를 포착할지 모른다.

> 이러한 '소규모 재사용'은 시스템의 복잡도를 극적으로 줄여준다. 그리고 소규모 재사용을 제대로 익혀야 대규모 재사용이 가능하다.

TEMPLATE METHOD 패턴은 고차원 중복을 제거할 목적으로 자주 사용하는 기법이다.

```java
public class VacationPolicy {
    public void accrueUSDivisionVacation() {
        calculateBaseVacationHours();
        checkUSLegalMinimum();
        applyToPayroll();
    }

    public void accrueEUDivisionVacation() {
        calculateBaseVacationHours();
        checkEULegalMinimum();
        applyToPayroll();
    }
}
```

```java
public abstract class VacationPolicy {
    public void accrueVacation() {
        calculateBaseVacationHours();
        alterForLegalMinimums();
        applyToPayroll();
    }

    private void calculateBaseVacationHours() {}
    protected abstract void alterForLegalMinimums();
    private void applyToPayroll() {}
}

public class USVacationPolicy extends VacationPolicy {
    @Override
    protected void alterForLegalMinimums() {
        // 미국 법 기준 적용
    }
}

public class EUVacationPolicy extends VacationPolicy {
    @Override
    protected void alterForLegalMinimums() {
        // 유럽 법 기준 적용
    }
}
```

- 중복된 부분을 하나의 템플릿으로 제작하고, 서로 다른 부분은 추상 클래스를 사용해서 하위 로직에서 정의해서 처리할 수 있도록 만들었다.

> 이 부분을 React 관점에서 생각해봤는데, 어떤 예시가 있을까 좀 생각을 해봤습니다.

```jsx
function Common1() {
  return (
    <div>
      <h1>안녕하세요</h1>
      <span>제 이름은 이재진 입니다.</span>
    </div>
  );
}

function Common2() {
  return (
    <div>
      <h1>안녕하세요</h1>
      <span>제 이름은 김준우 입니다.</span>
    </div>
  );
}
```

위 두 가지 컴포넌트는 동일한 구조를 가지고 있습니다. 하지만 이재진과, 김준우라는 조금 다른 부분이 있죠, 이런 부분을 children으로 만들어서 사용할 수 있지 않을까 싶었습니다.

```jsx
function Parent({ children }) {
  return (
    <div>
      <h1>안녕하세요</h1>
      {children}
    </div>
  );
}

function Common1() {
  return (
    <Parent>
      <span>제 이름은 이재진 입니다.</span>
    </Parent>
  );
}

function Common2() {
  return (
    <Parent>
      <span>제 이름은 김준우 입니다.</span>
    </Parent>
  );
}
```

이렇게 사용할 수 있을 것 같습니다. 이렇게 하면 책에서 이야기한 것 처럼, 중복되지 않느 정보만 제공해서, '빠진 구멍'을 메운다는 표현도 적절하게 쓰일 수 있을 것 같습니다.

더 나아가 확장성 측면에서, 동일한 `<Parent>`를 사용한다고 하면, 기존의 `제 이름은 ~ 입니다.`가 아닌 다른 형태의 구조도 충분히 커버가 가능하기 때문에 더 유연한 시스템 설계가 가능하지 않을까라는 생각을 합니다.

## 표현하라

- 자신이 이해한 코드를 짜기는 쉽다, 하지만 나중에 코드를 유지보수할 사람이 코드를 짜는 사람만큼이나 문제를 깊이 이해할 가능성은 희박하다.

- 시스템이 점차 복잡해 지면서 유지보수 개발자가 시스템을 이해하느라 보내는 시간이 점점 늘어나고 동시에 코드를 오해할 가능성도 점점 커진다. 그렇기 때문에 코드의 의도를 분명하게 표현해야 한다.

- 좋은 이름 선택
- 함수와 클래스 크기를 가능한 줄인다.
- 표준 명칭을 사용한다. 클래스 이름에 사용된 표준 패턴의 이름을 함께 넣는다. 그러면 설계 의도를 이해하기 쉬워진다.
- 단위 테스트 케이스를 꼼꼼히 작성한다. 테스트를 읽어보면 클래스의 기능이 한 눈에 들어온다.

> 마지막에 '나중에 코드를 읽을 사람은 바로 자신일 가능성이 높다는 사실을 명심하자' 라고 이야기하는 부분이 있습니다.

저는 이 말에 조금 공감을 했습니다.
예전에 만들어놨던 코드를 리팩터링하고있는데, 분명 제가 짰던 코드지만, 이해하는데 생각보다 많은 시간을 할애하고, 대부분 기능을 보고 파악하는게 아니라, 머리속에 남아있는 기억을 끄집어내어서 아 이때 이런 생각을 가지고 구현했었지 라고 생각하고, 리팩터링 하는 경우가 있었습니다.

그나마 제가 만든 코드였기에 이해가 가능했지만, 만약 다른 모르는 사람이 제 코드를 읽었다면 더더욱이 이해하기 어려울 것 같았습니다.

제가 여기서 해야할 일은, 이미 설계를 잘못 만들었기 때문에, 끊임없이 리팩터링하면서, 미래의 저에게 혹은 다른 사람이 보았을 때, 쉽게 이해가 가능하도록 코드를 작성해야 겠구나 생각이 들었습니다.

## 클래스와 메서드 수를 최소로 줄여라

위에서 언급해던 내용들을 극단으로 치달으면 득보다 실이 많아진다. 클래스와 메서드 크기를 줄이자고 조그만 클래스와 메서드를 수없이 만드는 사례도 없지 않다.

- 무의미하고 독단적인 정책 탓에 클래스 수와 메서드 수가 늘어나기도 한다.
- 무조건 인터페이스를 생성하라고 요구하는 구현 표준도 있다.
- 자료 클래스와 동작 클래스는 무조건 분리해야한다고 주장하기도 한다.
- 가능한 독단적인 견해는 멀리하고 실용적인 방식을 택한다.

목표는 함수와 클래스 크기를 작게 유지하면서 동시에 시스템 크기도 작게 유지하는데 있다.

하지만 우선순위가 낮다. 테스트 케이스를 만들고 중복을 제거하고 의도를 표현하는 작업이 더 중요하다.

> 이 부분은 뭐 어쩌란 건지 잘 모르겠다는 느낌을 받았습니다. 클래스 메서드 수를 최소로 줄이라는건지, 근데 중요한게 많으니간 줄이지 말라는건지...

> 그냥 단편적으로 든 생각은, 그냥 인지만 하고 있어라 였던 것 같습니다. 클래스와 메서드 수가 많아지면, 관리하기 어렵다는 사실모두가 아는 사실이기 때문에 이런 이야기를 하지 않았을까? 라는 생각이 들었고, 그 외에 중요한 작업이 많이 때문에 그거에 먼저 집중하고 나중에 클래스와 메서드 수를 줄일 생각을 해라 뭐 이런 의미가 아닐까 라는 생각을 합니다.

## 결론

이 책에서 소개하는 기법은 저자들이 수십년동안 쌓은 경험의 정수다. 단순한 설계 규칙을 따른다면 우수한 기법과 원칙을 단번에 활용할 수 있다.

> 사실 좋은 말은 아닌것 같습니다. 너네는 의미를 이해할 필요도 없고, 경험치도 없으니깐 '그냥 써' 라는 말처럼 들리기 때문입니다.

> 결국 경험이 없으니 우선 써 봐라... 맞는 이야기이긴 하지만, 너무 맹신하고 사용하는 것 보다는, 이런 저런 상황도 겪어보면서 발전해 가는게 본인 스스로에게도 더 좋지 않을까 라는 생각을 합니다.

> 물론 책에서 언급했듯이, 이미 선배 개발자들이 겪은 경험을 바탕으로 만들었기 때문에 맞는 말이고, 검증된 이야기 이겠지만, 그들이 경험하는 환경과, 현재에 와서 저희가 경험하는 환경이 다르기 때문에 다른 경험에 대해서도 열어두는 자세가 좋을 것 같다고 생각합니다.

# 감상문

해당 장이 시작하는 처음에는 '창발성'을 이야기하면서 작은 단위의 설계를 단순하게 따라하면 큰 설계도 따라온다는 것을 설명합니다. 그 이후에 설명한 모든 것들이 하나의 작은 설계들이고, 이러한 설계를 따르면 결국 큰 설계에서도 좋은 효과가 나타날 것 이다. 이런 말을 하고싶었던게 아닐까 라는 생각을 했습니다.
