# 8장 경계

- 시스템에 들어가는 모든 소프트웨어를 직접 개발하는 경우는 드물기 때문에 어떤 식으로든 외부 코드를 우리 코드에 깔끔하게 통합해야만 한다.

## 외부 코드 사용하기

- 인터페이스 제공자는 적용성을 최대한 넓히려 애쓰지만 반면, 인터페이스 사용자는 자신의 요구에 집중하는 인터페이스를 바라기 때문에 시스템 경계에서 문제가 생길 소지가 많다.

Map이 제공하는 메서드

```java
• clear() void — Map
• containsKey(Object key) boolean — Map
• containsValue(Object value) boolean — Map
• entrySet() Set — Map
• equals(Object o) boolean — Map
• get(Object key) Object — Map
• getClass() Class<? extends Object> — Object
• hashCode() int — Map
• isEmpty() boolean — Map
• keySet() Set — Map
• notify() void — Object
• notifyAll() void — Object
• put(Object key, Object value) Object — Map
• putAll(Map t) void — Map
• remove(Object key) Object — Map
• size() int — Map
• toString() String — Object
• values() Collection — Map
• wait() void — Object
• wait(long timeout) void — Object
• wait(long timeout, int nanos) void - Object
```

- Map은 굉장히 다양한 인터페이스로 수많은 기능을 제공한다. 따라서 기능성과 유연성은 확실히 유용하지만 그만큼 위험도 크다. (clear() 메서드, 객체 유형 제한 X 등의 이유)

Sensor라는 객체를 담은 Map

```java
Map sensors = new HashMap();
```

Sensor 객체를 가져오는 코드

```java
Sensor s = (Sensor)sensors.get(sensorId);
```

- 위와 같은 코드가 한 번이 아니라 여러 차례 나온다. 즉, Map이 반환하는 Object를 올바른 유형을 변환할 책임은 Map을 사용하는 클라이언트에 있다.

Generic(제네릭)을 사용하여 리팩터링한 코드

```java
Map<String, Sensor> sensors = new HashMap<Sensor>();
...
Sensor s = sensors.get(sensorId);
```

- 그렇지만 위 방법도 "Map<String, Sensor>가 사용자에게 필요하지 않은 기능까지 제공한다"는 문제는 해결하지 못한다.

최종 리팩터링 코드

```java
public class Sensors {
  private Map sensors = new HashMap();

  public Sensor getById(String id) {
    return (Sensor) sensors.get(id);
  }

  // 이하 생략
}
```

- 경계 인터페이스인 Map을 Sensors 안으로 숨긴다. 따라서 Map 인터페이스가 변하더라도 나머지 프로그램에는 영향을 미치지 않는다.
- Sensors 클래스 안에서 객체 유형을 관리하고 변환하기 때문에 제네릭을 사용하든 하지 않든 더 이상 문제가 되지 않는다.
- Map과 같은 경계 인터페이스를 이용할 때는 이를 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의한다.

> 해당 파트에서는 Map 인터페이스를 중심으로 설명하고 있지만, '외부 코드 사용하기'라는 파트 제목과, 제공자와 사용자 사이의 긴장 관계를 언급한 부분에서 저는 수많은 라이브러리들이 떠올랐습니다.
> 실제로 프로젝트에서 다양한 외부 라이브러리를 사용하면서도 "내가 이걸 의도에 맞게 잘 쓰고 있는 걸까?"라는 의문이 자주 들었고, 공식 문서를 다시 찾아보며 설계 의도에 맞지 않게 활용하려고 했던 사실을 뒤늦게 알게 되는 경우도 많았습니다.
> 반대로, 공개 API(유틸함수, 커스텀 훅 같은) 제공자 입장이 되었을 때를 돌이켜보면 같이 프로젝트를 했었던 팀원(사용자)분도 공개 API임에도 불구하고 이것을 어떻게 활용하는지에 대해 저한테 다시 여쭤보는 상황도 있었어서 신중히 설계를 하지 못했다고 생각한 적이 있었습니다.
> 그래서 이 파트를 보면서 이러한 능력을 기르는 것이 단순히 코드를 짜는 것보다 훨씬 더 중요한 소프트웨어 설계 역량이라고 다시금 느꼈습니다.

## 경게 살피고 익히기

- 외부 코드를 사용하면 빠르게 기능을 구현할 수 있지만, 사용하는 방법을 익히기와 통합하기는 어렵다.
- 우리쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히는 것, 이를 짐 뉴커크(Jim Newkirk)는 학습 테스트라 부른다.
- 학습 테스트는 API를 사용하려는 목적에 초점을 맞춘다.
