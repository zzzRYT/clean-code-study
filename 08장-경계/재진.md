# 08장 경계

- 시스템에 들어가는 모든 소프트웨어를 직접 개발하는 경우는 드물다.

1. 오픈소스 활용
2. 외부 패키지 활용
3. 사내 다른 팀이 제공하는 컴포넌트 사용

> 어떤 식이던 외부 코드를 우리는 깔끔하게 통합 해야 한다.

## 외부코드 사용하기

- 외부 패키지 제공하는 더 많은 사용하자가 사용하게 하기 위해서 범용적으로 유연하게 코드를 짠다.
- 반면에 사용자는 본인에게 조금더 집중하는 인터페이스를 원한다.

> 이러한 인터페이스를 `경계 인터페이스`라 부르는 것 같습니다.

> 예시로 java.util.Map을 보자

`Map`이 제공하는 기능성과 유연성은 확실히 유용하지만 그만큼 위험도 크다.

```
Map을 만들어서 여기저기 넘긴다고 가정했을 때,
사용하의 누구든지 Map을 지울 권한이 있다.

설계시에 Map에 특정 객체를 저장한다고 약속했다 하더라도, 마음만 먹으면 사용자는 어떤 객체 유형도 추가할 수 있다.
```

Sensor라는 객체를 담는 Map을 만들때 다음과 같이 쓸 수 있다.

```java
Map sensors = new HashMap();
```

`sensor`가 필요한 코드에서 다음 같이 사용할 수 있따.

```java
Sensor s = (Sensor)sensor.get(sensorId)
```

위와 같은 코드가 한 번이 아니라, 여러 차례 나온다.

즉, Map이 반환하는 Object를 올바른 유형으로 변환할 책임이 Map을 사용하는 클라이언트에게 있다는 의미이다.

이러한 코드는 깨끗한 코드라 보기는 어렵다.

- 게다가 위와 같은 코드는 의도가 명확하게 드러나지 않는다.

다음과 같이 개선할 수 있다.

```java
//객체화
Map<String, Sensor> sensor = new HashMap<Sensor>();

//사용
Sensor s = sensor.get(sensorId);
```

위 방법도 "Map(String, Sensor)가 사용자에게 필요하지 않는 기능까지 제공한다"라는 문제를 해결하지는 못한다.

또한 Map의 인터페이스가 변할 경우, 수정할 코드가 상당히 많아진다.(사용하는 부분 모두를 고쳐야 하는 경우가 생기기 때문)

조금 더 깔끔하게 개선할 수 있다.

```java
public class Sensors {
    private Map sensors = new HashMap();

    public Sensor getById(String id) {
        return (Sensor) sensor.get(id);
    }
}
```

- Map을 Sensor클래스 안으로 캡슐화를 시키면, 인터페이스가 변하더라도, 나머지 프로그램을 수정할 필요가 없어진다. Sensor클래스만 수정하면 되기 때문이다.
- Sensor클래스는 사용하에 맞게 필요한 프로그램에 인터페이스만 제공한다. 그래서 코드를 이해하기 쉽지만, 잘못사용하는 것을 막을 수 있다.
- 설계 규칙을 따르도록 강제시킬 수 있다.

> Map과 같은 경계 인터페이스를 사용할 때 무조건 캡슐화 하라는 소리가 아니다. 여기저기 넘기는 상황이 온다면 캡슐화 하는 것이 하나의 방식이라는 이야기 이다.

- 이를 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의한다.
- 공개 API의 인수로 넘기거나 반환값으로 사용하는 것 또한 절절하지 않다.

> 해당 챕터의 이름을 외부 코드 사용하기 보다 `경계 인터페이스`라는 이름을 사용하면 어땠을까 하는 생각을 했습니다. 해당 챕터에서는 외부에서 가져와서 사용하는 인터페이스를 예를 들어서 설명하고 있는데, 여기서 주요하게 등장하는 개념이 `경계 인터페이스`입니다.

> 결국 글쓴이가 하고싶었던 이야기는, 이러한 `경계 인터페이스`를 사용할 때에는 여러곳에서 사용하는 경우가 생기는데, 이럴 때 캡슐화를 통해서 다음과 같은 일을 수행할 수 있다고 알려주는 것 같습니다.

- 코드 강제
- 유지보수 쉬움
- 필요한 인터페이스만 사용 가능
- 의미 전달이 더 명확해 진다.
- 사용하는 정확한 인터페이스를 알지 못해도 코드를 사용할 수 있다.

## 경계 살피고 익히기

- 외부 코드를 익히는 것은 어렵다.
- 외부 코드를 통합하기도 어별다.
- 두 가지를 동시에 수행하는 것은 두 배나 어렵다.

조금 다르게 적용해 보자, 곧바로 우리쪽 코드를 작성해 외부 토드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히면 어떨까?

> 짐 뉴커스 (Jim Newkrik)는 이름 `학습 테스트`라고 불렀다.

### Log4j 익히기

로깅 기능을 직접 구현하는 대신 Log4j패키지를 사용하려고 하는데, 이 때 학습 테스트를 작성하는 방법을 설명한다.

1. 처음 시도

```java
Logger logger = Logger.getLogger("MyLogger");
logger.info("hello");
```

`Appender`가 없기 때문에 오류가 난다고 한다.

2. Appender 추가 시도

```java
ConsoleAppender appender = new ConsoleAppender();
logger.addAppender(appender);
logger.info("hello");
```

출력 스트림이 없기 때문에 에러가 발생

3. 출력 스트림 명시

```java
logger.addAppender(new ConsoleAppender(
    new PatternLayout("%p %t"),
    ConsoleAppender.SYSTEM_OUT));
logger.info("hello");
```

- `성공` hello가 출력됨

4. 테스트를 통해서 이상한점 발견(경계 테스트)

- `ConsoleAppender.SYSTEM_OUT`을 제거해도 출력됨
- `PatternLayout`을 제거하면 실패함
- `공식 문서`를 읽어보니 `ConsoleAppender`는 "설정되지 않은 상태"임, `log4j`버그거나, 적어도 일관성 부족으로 여겨진다.

학습한 내요을 토대로 독자적인 클래스 래퍼를 구현하면, `log4j`경계 인터페이스는 몰라도 된다.

> 그냥 `학습 테스트`를 하는 방식에 대한 일련의 과정을 알려주는 챕터 같았습니다. 해당 부분을 보고 느낀점이, "어? 이거 TDD랑 좀 비슷한거 아닌가?"라는 생각이 들었습니다.

> 두 개발 방식 모두, 실제코드를 작성 전에 미리 작성해 보면서 에러를 추려내는 방식이 비슷하다고 생각이 들었습니다.

> 하지만 두 가지는 목적이 조금씩 다릅니다.

| 항목             | 학습 테스트 (Learning Test)                | 테스트 주도 개발 (TDD)                             |
| ---------------- | ------------------------------------------ | -------------------------------------------------- |
| **목적**         | 라이브러리/코드의 동작을 이해하고 확인     | 애플리케이션의 기능을 설계하고 구현                |
| **대상**         | 외부 라이브러리, 복잡한 API, 모르는 코드   | 내가 만들 기능, 모듈, 클래스                       |
| **작성 시점**    | 학습/탐험 단계에서                         | 기능 개발 시작 전에                                |
| **지속성**       | 임시적으로 작성하거나, 나중에 삭제         | 영구적으로 코드베이스에 유지                       |
| **실패 시 의미** | "이렇게 동작하지 않는구나" → 학습 기회     | "내 코드가 요구사항을 만족하지 못한다" → 수정 필요 |
| **결과물**       | 이해를 위한 문서 겸 실험 코드              | 신뢰 가능한 테스트 스위트                          |
| **사용 예**      | zustand의 상태 업데이트가 어떻게 작동할까? | 새로운 Todo 기능을 구현하기 전에 예상 동작 정의    |

두 방식은 상호보완적 입니다.

- 학습 테스트는 TDD를 하기 위한 준비 작업으로 자주 쓰입니다.
- TDD 중간에 외부 라이브러리를 써야 할 때 → 잠깐 학습 테스트 작성 → 이해한 뒤 TDD로 돌아오기

두 가지 중 하나를 쓴 다는 느낌보다는 적절한 타이밍에 적절한 방식을 사용하는게 중요해 보입니다.
