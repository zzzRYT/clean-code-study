# 08장 경계

- 시스템에 들어가는 모든 소프트웨어를 직접 개발하는 경우는 드물다.

1. 오픈소스 활용
2. 외부 패키지 활용
3. 사내 다른 팀이 제공하는 컴포넌트 사용

> 어떤 식이던 외부 코드를 우리는 깔끔하게 통합 해야 한다.

## 외부코드 사용하기

- 외부 패키지 제공하는 더 많은 사용하자가 사용하게 하기 위해서 범용적으로 유연하게 코드를 짠다.
- 반면에 사용자는 본인에게 조금더 집중하는 인터페이스를 원한다.

> 이러한 인터페이스를 `경계 인터페이스`라 부르는 것 같습니다.

> 예시로 java.util.Map을 보자

`Map`이 제공하는 기능성과 유연성은 확실히 유용하지만 그만큼 위험도 크다.

```
Map을 만들어서 여기저기 넘긴다고 가정했을 때,
사용하의 누구든지 Map을 지울 권한이 있다.

설계시에 Map에 특정 객체를 저장한다고 약속했다 하더라도, 마음만 먹으면 사용자는 어떤 객체 유형도 추가할 수 있다.
```

Sensor라는 객체를 담는 Map을 만들때 다음과 같이 쓸 수 있다.

```java
Map sensors = new HashMap();
```

`sensor`가 필요한 코드에서 다음 같이 사용할 수 있다.

```java
Sensor s = (Sensor)sensor.get(sensorId)
```

위와 같은 코드가 한 번이 아니라, 여러 차례 나온다.

즉, Map이 반환하는 Object를 올바른 유형으로 변환할 책임이 Map을 사용하는 클라이언트에게 있다는 의미이다.

이러한 코드는 깨끗한 코드라 보기는 어렵다.

- 게다가 위와 같은 코드는 의도가 명확하게 드러나지 않는다.

다음과 같이 개선할 수 있다.

```java
//객체화
Map<String, Sensor> sensor = new HashMap<Sensor>();

//사용
Sensor s = sensor.get(sensorId);
```

위 방법도 "Map(String, Sensor)가 사용자에게 필요하지 않는 기능까지 제공한다"라는 문제를 해결하지는 못한다.

또한 Map의 인터페이스가 변할 경우, 수정할 코드가 상당히 많아진다.(사용하는 부분 모두를 고쳐야 하는 경우가 생기기 때문)

조금 더 깔끔하게 개선할 수 있다.

```java
public class Sensors {
    private Map sensors = new HashMap();

    public Sensor getById(String id) {
        return (Sensor) sensor.get(id);
    }
}
```

- Map을 Sensor클래스 안으로 캡슐화를 시키면, 인터페이스가 변하더라도, 나머지 프로그램을 수정할 필요가 없어진다. Sensor클래스만 수정하면 되기 때문이다.
- Sensor클래스는 사용하에 맞게 필요한 프로그램에 인터페이스만 제공한다. 그래서 코드를 이해하기 쉽지만, 잘못사용하는 것을 막을 수 있다.
- 설계 규칙을 따르도록 강제시킬 수 있다.

> Map과 같은 경계 인터페이스를 사용할 때 무조건 캡슐화 하라는 소리가 아니다. 여기저기 넘기는 상황이 온다면 캡슐화 하는 것이 하나의 방식이라는 이야기 이다.

- 이를 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의한다.
- 공개 API의 인수로 넘기거나 반환값으로 사용하는 것 또한 절절하지 않다.

> 해당 챕터의 이름을 외부 코드 사용하기 보다 `경계 인터페이스`라는 이름을 사용하면 어땠을까 하는 생각을 했습니다. 해당 챕터에서는 외부에서 가져와서 사용하는 인터페이스를 예를 들어서 설명하고 있는데, 여기서 주요하게 등장하는 개념이 `경계 인터페이스`입니다.

> 결국 글쓴이가 하고싶었던 이야기는, 이러한 `경계 인터페이스`를 사용할 때에는 여러곳에서 사용하는 경우가 생기는데, 이럴 때 캡슐화를 통해서 다음과 같은 일을 수행할 수 있다고 알려주는 것 같습니다.

- 코드 강제
- 유지보수 쉬움
- 필요한 인터페이스만 사용 가능
- 의미 전달이 더 명확해 진다.
- 사용하는 정확한 인터페이스를 알지 못해도 코드를 사용할 수 있다.

## 경계 살피고 익히기

- 외부 코드를 익히는 것은 어렵다.
- 외부 코드를 통합하기도 어별다.
- 두 가지를 동시에 수행하는 것은 두 배나 어렵다.

조금 다르게 적용해 보자, 곧바로 우리쪽 코드를 작성해 외부 토드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히면 어떨까?

> 짐 뉴커스 (Jim Newkrik)는 이름 `학습 테스트`라고 불렀다.

### Log4j 익히기

로깅 기능을 직접 구현하는 대신 Log4j패키지를 사용하려고 하는데, 이 때 학습 테스트를 작성하는 방법을 설명한다.

1. 처음 시도

```java
Logger logger = Logger.getLogger("MyLogger");
logger.info("hello");
```

`Appender`가 없기 때문에 오류가 난다고 한다.

2. Appender 추가 시도

```java
ConsoleAppender appender = new ConsoleAppender();
logger.addAppender(appender);
logger.info("hello");
```

출력 스트림이 없기 때문에 에러가 발생

3. 출력 스트림 명시

```java
logger.addAppender(new ConsoleAppender(
    new PatternLayout("%p %t"),
    ConsoleAppender.SYSTEM_OUT));
logger.info("hello");
```

- `성공` hello가 출력됨

4. 테스트를 통해서 이상한점 발견(경계 테스트)

- `ConsoleAppender.SYSTEM_OUT`을 제거해도 출력됨
- `PatternLayout`을 제거하면 실패함
- `공식 문서`를 읽어보니 `ConsoleAppender`는 "설정되지 않은 상태"임, `log4j`버그거나, 적어도 일관성 부족으로 여겨진다.

학습한 내요을 토대로 독자적인 클래스 래퍼를 구현하면, `log4j`경계 인터페이스는 몰라도 된다.

> 그냥 `학습 테스트`를 하는 방식에 대한 일련의 과정을 알려주는 챕터 같았습니다. 해당 부분을 보고 느낀점이, "어? 이거 TDD랑 좀 비슷한거 아닌가?"라는 생각이 들었습니다.

> 두 개발 방식 모두, 실제코드를 작성 전에 미리 작성해 보면서 에러를 추려내는 방식이 비슷하다고 생각이 들었습니다.

> 하지만 두 가지는 목적이 조금씩 다릅니다.

| 항목             | 학습 테스트 (Learning Test)                | 테스트 주도 개발 (TDD)                             |
| ---------------- | ------------------------------------------ | -------------------------------------------------- |
| **목적**         | 라이브러리/코드의 동작을 이해하고 확인     | 애플리케이션의 기능을 설계하고 구현                |
| **대상**         | 외부 라이브러리, 복잡한 API, 모르는 코드   | 내가 만들 기능, 모듈, 클래스                       |
| **작성 시점**    | 학습/탐험 단계에서                         | 기능 개발 시작 전에                                |
| **지속성**       | 임시적으로 작성하거나, 나중에 삭제         | 영구적으로 코드베이스에 유지                       |
| **실패 시 의미** | "이렇게 동작하지 않는구나" → 학습 기회     | "내 코드가 요구사항을 만족하지 못한다" → 수정 필요 |
| **결과물**       | 이해를 위한 문서 겸 실험 코드              | 신뢰 가능한 테스트 스위트                          |
| **사용 예**      | zustand의 상태 업데이트가 어떻게 작동할까? | 새로운 Todo 기능을 구현하기 전에 예상 동작 정의    |

두 방식은 상호보완적 입니다.

- 학습 테스트는 TDD를 하기 위한 준비 작업으로 자주 쓰입니다.
- TDD 중간에 외부 라이브러리를 써야 할 때 → 잠깐 학습 테스트 작성 → 이해한 뒤 TDD로 돌아오기

두 가지 중 하나를 쓴 다는 느낌보다는 적절한 타이밍에 적절한 방식을 사용하는게 중요해 보입니다.

### 학습 테스트는 공짜 이상이다.

학습 테스트는 필요한 지식만 확보하는 손쉬운 방법이다.

학습 테스트는 패키지가 예상대로 도는지 검증한다.
통한한 이후라고 하더라도, 패키지가 우리 코드와 호환되리라는 보장은 없다.

패키지 새 버전이 나올 때 마다 새로운 위험이 생긴다.

경계 테스트가 있다면, 패키지의 새 버전으로 이전하기 쉬워진다. 그렇지 않다면 낡은 버전을 필요 이상으로 사용하려는 유혹에 빠지기 쉽다.

> 이 부분에 대해서 조금 공감하는 부분이 있는데, 이전에 MSW라는 라이브러리를 사용한 적이 있습니다. 그 버전을 사용하다가 중간에 2.0version으로 갑작스럽게 업데이트가 된 적이 있는데, 앞자리 버전이 바뀌는 바람에 패키지를 업데이트했을 때 기존에 사용하던 코드 전체를 사용하지 못하는 경우가 생긴적이 있습니다. 버전을 낮춰서 사용해도 괜찮았었을 것 같은데, 결국에는 새로운 버전은 이전 버전의 개선 버전이라고 생각합니다. 더욱 개발자 친화적으로 사용자 친화적으로 변화하는 습성이 있다고 생각해서 공부를 하고 적용을 했습니다. 그 과정에서 공식문서의 중요성에 대해서 깨닫는 시간이었는데, 그 때, 이 경계 테스트, 학습 테스트를 알고 있었더라면 더 좋지 않았을까 하는 생각을 합니다.

## 아직 존재하지 않는 코드를 사용하기

때로는 우리 지식이 경계를 너머 미치지 못하는 코드 영역도 있다.

예시로 글쓴이가 작업한 소프트웨어 개발 중 "송신기(Transmitter)"라는 하위 시스템이 있었다.

여기에 대한 지식이 거의 없었고, 그에 맞는 인터페이스도 정의하지 못한 상태였다.

- "송신기"의 하위 시스템과 가장 먼 부분부터 작업을 진행
- 우리의 작업과, 외부 작업의 경계에 대한 익힌다.
- 일 하면서 그 경계에 부딪혔다.
- 아직 API를 설계하지 않아 구체적으로 방법을 몰라, 구현을 뒤로 미룹
- 자체적으로 
> 이로서 얻은 이득인터페이스를 정의했다.


- 인터페이스를 전적으로 통제한다는 장점이 생겼고,
- 코드 가독성도 높이고, 코드 의도도 명확해 졌다.
- `Adapter 패턴`으로 API사용을 캡슐화해 API가 바뀔 때 수정할 코드를 한 곳에 모아, 유지 보수를 쉽게 만듦

> Adapter 패턴은, 우리나라에서는 220v를 사용하지만 일본은 110v를 사용하기 때문에 우리나라 콘센트를 사용하지 못합니다. 그럴 때, 변환해주는 변환기를 Adapter패턴에서는 일종의 어댑터로 부릅니다.

> 즉, 사용하는곳이 달라져도, 내가 사용하던 코드를 그대로 사용하게 할 수 있는게 Adapter 패턴의 장점인 것 이죠

- 해당 부분을 React에 맞게 조금 생각해 봤습니다.
- 이번에 제가 Kakao Maps Api를 공부해야 하는 일이 생겼는데, 그걸 예시로 이야기를 드리겟습니다.

- 저는 일단 kakao maps api를 잘 알지 못합니다. 그렇기 때문에 그리고, Kakao Maps API를 직접 제어할 수 없기 때문에, 유지 보수가 어려워 질 가능성이 있습니다(버전이 바뀌거나 할 때)

그래서 이 API를 하나의 추상 계층으로 감싸줍니다.

```tsx
export class KakaoMapService {
  private map: kakao.maps.Map;

  constructor(container: HTMLElement, options: kakao.maps.MapOptions) {
    this.map = new kakao.maps.Map(container, options);
  }

  setCenter(lat: number, lng: number) {
    const center = new kakao.maps.LatLng(lat, lng);
    this.map.setCenter(center);
  }
  //더 필요한 기능이 있으면 계속 추가
}
```

그리곤 실제 사용하는 부분에서는 미리 정의해둔 KakaoService만 보는 것이죠

```tsx
import { useEffect, useRef } from "react";
import { KakaoMapService } from "../lib/kakao/KakaoMapService";

export default function MapViewer() {
  const mapContainerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (mapContainerRef.current) {
      const mapService = new KakaoMapService(mapContainerRef.current, {
        center: new kakao.maps.LatLng(37.5665, 126.978),
        level: 3,
      });

      mapService.setCenter(37.5665, 126.978);
    }
  }, []);

  return (
    <div ref={mapContainerRef} style={{ width: "100%", height: "400px" }} />
  );
}
```

이렇게 하면 추후에 API가 변경되 더라도, 한 곳만 고치면 됩니다.

> 물론 실제 API에 대해서는 이렇게 까지 하기는 어렵다고 생각합니다. 하지만 이 방식을 백엔드와, 프론트엔드 사이의 경계로 생각하고 작성한다면 꽤나 유용한 코드가 탄생할 것 이라고 생각했습니다.

> 외부에서 사용되는 API는 변경되는 일이 생각보다 그렇게 많지 않습니다. 큼직큼직한 메이져 변화가 자주 오지는 않죠

> 하지만 같은 프로젝트를 진행하고 있는 입장에서 조금만 요구사항이나, 변경사항이 생기면 그 코드에 맞게 백엔드와 프론트엔드가 모두 코드를 변경해야하는 불편함이 생길 수 있고, 그 과정속에서 비효율적으로 코드를 수정하게 될 수 있습니다. 그런 사황을 대비하면 좋은 효과를 볼 수 있을 것 이라고 생각했습니다.

## 깨끗한 경계

통제하지 못하는 코드를 사용할 때는 너무 많은 투자를 하거나, 변경 비용이 지나치게 커지지 않도록 주의해야 한다.

- 경계에 위치하는 코드는 깔끔히 분리한다.
- 테스트 케이스를 작성한다.
- 통제 불가능한 외부 패키지에 의존하기 본다는 통제 가능한 우리 코드에 의존하는 편이 훨씬 좋다.

> 위에서 언급했던

- 새로운 클래스로 경계를 감싸거나
- Adapter 패턴을 사용해라

# 감상문

경계라는 단어로 부르지는 않았지만, 이러한 경계에 대해 고민을 한 적이 있습니다. 위에서도 한 번 언급했던, 프론트엔드와 백엔드 사이 수정이 발생했을 때 인데, 새로운 기능이 생겼을 때, 혹은 수정이 발생했을 때 효율적으로 코드를 작성 수정하는 방법에 대해서 생각을 했습니다.

API를 자동으로 제너레이트해주는 라이브러리인데, 저는 이 기능을 보고 좋다고만 생각하고, 생각할 생각만 했습니다. 하지만 이번 글을 읽고, 생각이 좀 바뀐 것 같습니다.

API를 작성, 수정하는 것을 손쉽게 하기 위해서 자동화 라이브러리를 사용한 다는 것은, 결국 내가 통제 불가능한건 똑같은건 아닌가?라는 생각을 했습니다. 그래서 이러한 경계코드에 직접 wrapper contents를 만들어서 사용을 해봐야겠다 생각을 하게 된 것 같습니다.
