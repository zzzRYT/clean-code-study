# 08장 경계

> 시작하기에 앞서 "경계" 라는 말이 와닫지 않았다. 이게 뭔지 찾아봤다.
> 경계(Boundaries)는 우리가 작성한 코드와 외부 시스템(라이브러리, 프레임워크, 타 시스템 등) 사이의 접점이라고 한다.
> 7장 오류처리 문단에서 이야기하던 "외부 api는 래퍼클래스(Wrapper)로 씌워야 한다"는 내용이 이 장에서 이어질 꺼 같다.

- 시스템 에 들어가는 모든 소프트웨어를 직접 개발하는 경우는 드물다.
- 어떤 식으로든 이 외부 코드를 우리 코드에 깔끔하게 통합 해야만 한다.

## 외부 코드 사용하기

- 패키지 제공자나 프레임워크 제공자는 적용성을 최대한 넓히려 한다.
- 사용자는 자신의 요구에 집중하는 인터페이스를 바란다.
- 이런 긴장으로 인해 시스템 경계에 문제가 생길 소지가 많다.

- 예시를 위한 MAP사용 코드

```java
// 개선 전
Map sensors = new HashMap();
Sensor s = (Sensor)sensors.get(sensorld);
```

```java
// 개선 후
public class Sensors {
  private Map sensors = new HashMap();

  public Sensor getById(String id) {
      return (Sensor) sensors.get(id);
  }
  // 이하 생략
}
```

> java에 익숙하지 않음 + map 자료구조에 대한 이해도가 적어서 약간 찾아보며 이해해 봤다. Sensors로 묶는것의 의미를 이해하볼려고 해봤다.
> 개선 전 코드를 보면 sensors은 그냥 Map 자료구조 이다. 그래서 Map에서 get 메서드를 사용해서 넣어둔 데이터를 찾아본다. 마치 js에서 []배열에 .find(), .filter() 를 사용하듯이 말이다. 또한 (Sensor)sensors.get(sensorld) 처럼 작성해 나오는 타입도 사용자가 직접 형변환을 시켜줘야한다. 물론 이부분은 책에서 제네릭을 사용하는걸로 순화시킨걸 보여주긴 한다.

> 이제 게션 후 코드를 보면 private Map sensors = new HashMap() 를 Sensors 이라는 래핑 클래스에서 필드로 담아 사용한다. 그리고 Map을 직접 사용하는게 아닌 Sensors 클래스에서 메서드를 작성해 놓아서 Map의 get을 사용한 로직을 넣어두고 사용자에게는 Map의 모든 메서드를 접근 시키는게 아닌 내가 사용하도록한 getById만 사용하도록 된다.

> 책에서는 이렇게 사용하면 Map의 인터페이스가 바뀌어도 나머지 프로그램에 영향을 미치지 않는다고 한다. 만일 Map이 바뀌면 모든 sensors를 사용하는곳을 바꾸는게 아닌 Sensors클래스의 메서드만 수정하면 되기 때문이다.

- Map 클래스를 사용할 때마다 위와 같이 캡슐화 하라는 소리가 아니다. Map을 혹은 유사한 경계 인터페이스를 여기저기 넘기지 말라는 말이다.
- 경계 인터페이스를 이용할 때는 이를 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의한다.

> Map을 사용할때마다 캡슐화하는게 중요한게 아니라.경계 인터페이스 예를들면 orm, 라이브러리 등등에서 제공하는 인터페이스를 내 프로젝트 곳곳에서 imort하지 말라는거 같다.

> 이걸 읽자마자 바로 prisma(orm) 인터페이스가 생각났다. 전 기수들의 코드를 참고해서 prisma의 인터페이스들을 최대한 해당 repository클래스에 묶기위해 내가 여러가지 타입을 직접만들고 사용한게 기억났다.

## 경계 살피고 익히기

- 외부 패키지 테스트가 우리 책임은 아니지만 우리 자신을 위해 우리가 사용할 코드를 테스트 하는 편이 바람직하다.

- 외부 코드를 익히기는 어렵다.
- 곧바로 코드를 사용하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히면 어떨까? 짐 뉴커크는 이를 "학습 테스트"라 부른다.

- 학습테스트는 통제된 환경에서 API를 제대로 이해하는지를 확인하는 셈이다.
  > 문서를 읽는거에 더 나아가 먼저 연습을 테스트 케이스로 하는 방법을 말하고 있다. 이를 gpt랑 이야기해보니 바로 학습 테스트 템플릿를 생성해 줬다. Jest, axios 테스트 템플릿을 만들어 주었는데, 좋은 학습 방향으로 느꼈다.

### Iog4j 익히기

- 로깅 기능을 직접 구현하는 대신 아파치의 log4j 패키지를 사용하려 한다고 가정하자.

> log4j 공부하던 글쓴이의 흐름을 설명해 보자.

1. Iog4j는 처음 사용해본다. 문서를 모두 읽는건 꽤 힘들다. 먼저 테스트케이스로 hello를 로그로 찍는걸 해보자.

2. Appender가 필요하다는 오류가 났다. 문서를 한번 찾아봤다. ConsoleAppender라는 클래스가 필요하다고 해 문서를 읽으며 추가해본다.

3. 이번엔 출력 스트림이 없다는걸 발견했다. 문서와 검색을 통해 추가해보자. 이번에는 실행이 잘 되었다.

4. 이번에는 ConsoleAppender를 왜 사용하는지 궁금해 졌다. 이제 문서를 읽고, 검색을하며 ConsoleAppender가 뭔지 이해하고 ConsoleAppender가 꼭 필요하지 않은걸 알게 된다.

5. 지금까지 테스트해보고 문서를 찾아보며 배운걸로 효율적인 테스트 케이스 몇가지를 작성해본다.

6. 이제 Iog4j를 좀 읽힌거 같다. 독자적인 콘솔 클래스로 만들어서 캡슐화 해준다. 그러면 나머지 프로그램들에서는 Iog4j의 인터페이스를 몰라도 된다.

> 쭉 읽어보니 내가 일단 적용하다가 모르는거 있으면 문서 보던거랑 똑같은 흐름이라 재미있었다. 나랑 다르면서도 이 내용의 핵심은 적용을 바로하는게 아닌, 테스트 케이스에서 먼저 실험하고, 실험이 끝나면 래핑클래스로 캡슐화를 하자는 거다.

## 학습 테스트는 공짜 이상이다

- 어쨋듣 API를 배워야 하므로 학습 테스트에 드는 비용은 없다.
- 학습 테스트는 이해도를 높여주는 정확한 실험이다. 투자하는 노력보다 얻는 성과가 크다.

- 새 버전이 나온다면, 학습 테스트를 돌려 차이가 있는지 확인한다.
- 새 버전이 우리 코드와 호환되지 않으면 학습 테스트가 이 사실을 곧바로 밝혀낸다.

- 실제 코드와 동일한 방식으로 인터페이스를 사용하는 테스트 케이스가 필요하다. 이런 경계 테스트가 있다면 패키지 새버전으로 이전하기 쉬워진다.
- 그렇지 않다면 낡은 버전을 필요 이상으로 오랫동안 사용하려는 유혹에 빠지기 쉽다.

## 아직 존재하지 않는 코드를 사용하기

- 경계와 관련해 또 다른 유형은 아는 코드와 모르는 코드를 분리하는 경계다. 떄로는 우리 지식이 경계를 너머 미치지 못하는 코드 영역도 있다. 때로는 더이상 내다보지 않기로 결정한다.
  > 내가 어떻게 구현해야할지, 또는 모르는 api를 나중에 적용해야할때를 이야기 하고 있다. 글쓴이의 경험을 따라가 보자

1. 무선통신 시스템에 들어갈 소프트웨어를 개발해야한다.

2. "송신기"라는 하위 시스템이 있고 이걸 책임진 사람들은 인터페이스도 정의 하지 못하고 있는 상황이다. 일단 나는 송신기에 대한 지식이 없다.

3. 하위 시스템과 먼 부분부터 작업을 시작하자. 경계가 어디쯤인지는 대략 감이 있었고 가끔 이 경계에 부딪쳤다. (내가 어떤걸 받아야할지, 사용해야할지 몰랐다)

4. 점차 우리에게 필요한 인터페이스가 무엇인지 알게 되었다. (어떤 데이터가 필요할지 점점 이해가 되었다.)

5. 아직 다른 팀 API가 설계되지 않아서 구체젝인 방법은 모른다. 그래서 구현을 미뤘다.

6. 자체적으로 인터페이스를 정의했다. (내가 뭘 필요한지는 눈치챘으니, 어떤걸 사용할꺼다 라는걸 정의했다.)

우리가 바라는 인터페이스를 구현하면 우리가 인터페이스를 전적으로 통제한다는 장점이 생긴다.

7. 이후에 저쪽팀이 송신기 API를 정의했을때, TransmitterAdapter를 구현해(API를 사용하는 클래스를 작성) 간극을 매웠다.

- 이와 같은 설계는 테스트도 아주 편하다. fake클래스(내가 임의로 정한 값을 주는 클래스)로 Controller 클래스를 해볼 수 있다.

- API인터페이스가 나온 다음 경계 테스트 케이스를 생성해 올바르게 사용하는지도 테스트 하자.

> 이 장의 핵심은 "외부 시스템(아직 설계되지 않았거나, 내가 모르는 것)에 의존해야 할 때, 기다리지 말고 내가 원하는 인터페이스를 먼저 정의하라."라고 이야기 할 수 있다. 글쓴이의 이야기를 따라서 그 생각의 흐름을 배울 수 있었다.

> 요기까지만 보고 이렇게 하는거구나 멋지다라고만 생각했는데 gpt이야기 추가로 인터페이스를 명확이 의존한다는 의미로 DIP 원칙을 실현하고, API의 설계가 변경되어도 TransmitterAdapter클래스만 수정하면 된다에서 변경에 유연한코드가 되었다고 한다. 들어보면 당연한데, 이런곳에도 글쓴이의 설계원칙에 대한 내용이 나와서 흥미로웠다.

## 깨끗한 경계

- 경계에서는 흥미로운 일이 많이 벌어진다. 변경이 대표적인 예다.
- 소프트웨어 설계가 우수하다면 변경하는데 많은 투자와 재작업이 필요하지 않다.

- 경계에 위치하는 코드는 깔끔히 분리한다.
- 테스트 케이스도 작성한다.

- 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하자. 새로운 클래스로 감싸거나, ADAPTER패턴을 사용해 우리가 원하는 인터페이스로 변환하자.

> ADAPTER패턴이 뭐일지 찾아봤다. 간단하게는 서로 호환되지 않는 인터페이스를 연결해주는 중간 다리 클래스 라고한다. "아직 존재하지 않는 코드를 사용하기" 파트의 TransmitterAdapter클래스도 이 패턴인거 같다.

> 위 예제를 봐서 어떤건지 이해는 했는데, 지금까지 이해했다고 생각한 래핑클래스와 ADAPTER패턴이 뭐가 다른지 찾아봤다. 나는 전부 래핑클래스로 중간 다리를 다 놨다고 생각했는데 패턴이름까지 따로 있길래 궁금했다.

> gpt 글을 가져와 봤다.
> 🔍 차이점: 의도와 사용 맥락
> | 항목 | 래퍼 클래스 (Wrapper) | 어댑터 패턴 (Adapter Pattern) |
> | ------------ | ------------------------------------------------ | ------------------------------------------------- |
> | **의도** | 특정 객체를 감싸서 기능을 제한하거나 확장 | **호환되지 않는 인터페이스를 연결** |
> | **맥락** | 내가 이미 아는 객체를 통제하고 싶을 때 | 외부 API, 레거시 코드처럼 **형태가 다른 코드와 연결**할 때 |
> | **타입 변경 여부** | 타입 그대로 유지 (`UserService` → `UserServiceWrapper`) | **인터페이스를 바꿈** (`ExternalService` → `EmailSender`) |
> | **예시** | `Map<String, Sensor>`를 Sensors로 감쌈 | `ExternalEmailService`를 `EmailSender`로 변환 |
> | **기반 패턴** | 데코레이터 또는 프록시 | 디자인 패턴 중 "Adapter" 패턴으로 명시됨 |

> 이를 보면 Adapter 패턴은 서로 다른 인터페이스를 연결하는 패턴인거같다. 래퍼클래스는 조금더 단순하게 인터페이스나 클래스, 자료구조등을 캡슐화하는데에 중점인거 같다. 사실 구현체 이름을 안보면 (Adapter라고 명시하지 않으면) 구별하기 어렵다고 생각했다. 익숙하지 않은 개념들을 연속해서 배우니 차이를 구별하지 못하는거 같다.

# 감상문

외부 경계와 경계가 있을때 해볼 수 있는 여러가지를 배웠다. 1. 경계가 있으면 분리하고 경계 인터페이스를 한곳에 묶기 2. 학습 테스트를 하기 3. 존재하지 않는 코드를 다루기 위해 인터페이스 설계부터 진행하고 연결은 Adapter Pattern을 사용하기 를 배웠다.
기존에 나는 외부라이브러리의 인터페이스를 한곳에서 다루어야 한다는 것만 어렴풋이 알았던거 같다. 경계에 대한 이렇게 많은 생각을 보고 배울 수 있어서 좋은 경험 이었다.
