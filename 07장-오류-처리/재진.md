# 감상평

# 07장 오류 처리

- 여기저기 흩어진 오류 처리 코드 때문에 실제 코드가 하는 일을 파악하기가 거의 불가능하다는 의미이다.
- 오류 처리는 중요하지만 오류 처리 코드로 인해 프로그램 논리를 이해하기 어려워진다면 깨끗한 코드라 부르기 어렵다.

## 오류 코드보다 예외를 사용해라

- 코드 중간에 오류를 처리하는 코드를 넣는 대신 예외로 던져 처리해라

```java
public class DeviceController {
    public void sendShutdown() {
        DeviceHandle handle = getHandle(DEV1);

        // 디바이스 상태를 점검한다.
        if (handle != DeviceHandle.INVALID) {
            // 레코드 필드에 디바이스 상태를 저장한다.
            retrieveDeviceRecord(handle);

            // 디바이스가 일시정지 상태가 아니라면 종료한다.
            if (record.getStatus() != DEVICE_SUSPENDED) {
                pauseDevice(handle);
                clearDeviceWorkQueue(handle);
                closeDevice(handle);
            } else {
                logger.log("Device suspended. Unable to shut down");
            }
        } else {
            logger.log("Invalid handle for: " + DEV1.toString());
        }
    }
}
```

해당 코드를 다음과 같은 코드로 개선할 수 있다.

```java
public class DeviceController {
    public void sendShutDown() {
        try {
            tryToShutDown();
        } catch (DeviceShutDownError e) {
            logger.log(e);
        }
    }

    private void tryToShutDown() throws DeviceShutDownError {
        DeviceHandle handle = getHandle(DEV1);
        DeviceRecord record = retrieveDeviceRecord(handle);

        pauseDevice(handle);
        clearDeviceWorkQueue(handle);
        closeDevice(handle);
    }

    private DeviceHandle getHandle(DeviceID id) {
        throw new DeviceShutDownError("Invalid handle for: " + id.toString());
    }
}

```

- 앞선 코드에서 디바이스 종료 알고리즘과, 오류를 처리하는 알고리즘이 뒤섞여 있었던 것을, 아래 코드에서는 분리했기 때문에 각 개념을 독립적으로 살펴보고 이해할 수 있다.

> 이 부분을 보고 느낀점은 결국 오류 처리도 하나의 작업으로 생각해서 우리가 전 장에서 함수를 "작업 단위로 쪼개서 리팩터링해라"와 동일한 의미로 해석할 수 있을 것 같습니다.

## Try-Catch-Finally문부터 작성하라

- try 블록에 들어가면, 어느 시점에서든 실행 중단된 후 catch블록으로 넘어갈 수 있다.

- try-catch-finally문은 트랜잭션과 비슷하다. try블록에서 무슨 일이 생기든지 catch 블록은 프로그램 상태를 일관성 있게 유지해야 한다.

다음과 같은 프로세스로 코드를 짤 수 있다.

1. 단위 테스트 구성
2. 단위 테스트에 맞게 코드를 구현
3. 코드에 예외 처리
4. 단위테스트 성공 -> 리팩터링 가능
5. catch블록에서 예외 유형 좁혀 세세한 예외 처리

먼저 강제로 예외를 일으키는 테스트 케이스를 작성한 후 테스트를 통과하게 코드를 작성하는 방법을 권장한다. 그러면 자연스럽게 try블록의 트랜잭션 범위 부터 구현하게 되므로 범위 내에서 트랜잭션의 본질을 유지하기 쉬워진다.

> 아직 단위 테스트를 프로젝트에서 많이 사용해 본 경험이 없어서 조금 따로 공부를 해봤습니다.

- TDD란? (Test-Driven-Development)의 약자
- TDD는 먼저 테스트 코드를 작성하고, 그 테스트 코드가 통과되도록 실제 코드를 작성하는 개발 방식입니다.

React + Typescript관점에서 이해를 해봤습니다.

1. 빈 파일(함수, 컴포넌트)생성
2. 테스트 코드 작성
3. 해당 테스트 코드를 성공시키기 위한 실제 코드를 작성

책에서 제공하는 방식의 예외처리

1. 예외가 발생할 만한 비동기 함수나, API호출 등에서 먼저 예외 블록을 잡는다.
2. 예외 상황을 정의한다.
3. UI에서 예외를 감지하고 상태 일관성을 유지(에러로 인해서 UI가 깨지지 않게)

책에서는 해당 방식을 이용하면, TDD 작성하는데 도움이 됩니다. 동작 방식이 동일하기 때문이죠,

마지막 문단에서 트랜잭션 본질을 유지하기 쉬워진다는 의미가 결국, 에러로 인해서 기존의 흐름이 깨지지 않게 유지해야 한다는 것을 의미하는 것 같습니다.

## 미확인(unchecked) 예외를 사용하라

메서드를 선언할 때 메서드가 반환하는 예외를 열거하는 확인된 예외는 OCP를 위반한다.

> OCP(Open Closed Principle): 확장에 있어서는 열려있지만, 수정에 대해서는 닫혀 있어야 한다는 원칙

확인된 예외를 사용하면, 하윈 단계에서 코드의 변경이 발생했을 때, 상위 단계 메서드 선언부를 전부 고쳐야 한다는 의미다.
throws 경로에 위치하는 모든 함수가 최하위 함수에서 던지는 예외를 알아야 하므로 캡슐화가 깨진다.

- 때로는 확인된 예외도 유용하다. 아주 중요한 라이브러리를 작성한다면 모든 예외를 잡아야 한다. 하지만 일반적인 애플리케이션은 의손성이라는 비용이 이익보다 크다.

> 해당 부분에 대해서 공부하면서 여러가지 디자인 패턴에 대해서 알아봤습니다. 그 중 Factory Pattern이라는 디자인 패턴과,observer pattern 데코레이션 패턴 이라는 걸 알게 되었습니다.

[팩토리 패턴](https://www.youtube.com/watch?v=eSLrZbPHgoI)
[옵져버 패턴](https://www.youtube.com/watch?v=aH4U6bfi_Ds&t=1s)
[데코레이션 패턴](https://www.youtube.com/watch?v=PU9sr-q8bys)

해당 패턴들은, 사실 해당 부분과는 관련이 없는 프로젝트 아키텍처에 관한 내용이라. 상관은 없는데. 비슷한 내용이라 담아봤습니다.
