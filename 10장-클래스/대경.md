# 10장 클래스

- 지금까지 우리는 코드 행과 코드 블록을 올바로 작성하는 법과 올바른 함수 구현과 관련 맺는 방식들 공부했다
- 이 장에스는 깨끗한 클래스를 다룬다.

## 클래스 체계

- static public, static private, private, public
- private 함수는 자신을 호출하는 public 함수 직후에 넣어 추상화 단계가 순차적으로 내려가게 한다.

### 캡슐화

- 가능한 private가 낫지만 반드시 숨겨야할 법칙도 없다.
- 때로는 함수를 protected로 선언해 태스트 코드에 접근을 허용하기도 한다.
- 캡슐화를 풀어주는 결정은 언제나 최후의 수단

## 클래스는 작아야 한다!

- 클래스를 만들 때 규척은 크기, 클래스는 작아야 한다.
- 얼마나 작아야 하나? 함수는 물리적 행수로 측정했지만 클래스는 맡은 책임을 센다.

- 클래스 이름은 해당 클래스 책임을 기술해야 한다.
- 간결한 이름이 떠오르지 않으면 책임이 너무 많아서다.
- processor, manager, super 같은 모호한 단어는 클래스에 여러 책임을 떠안겼다는 증거다.

### 단일 책임 원칙 SRP

- 단일 책임 원칙은 클래스나 모듈을 변경할 이유가 하나 뿐이어야 한다는 원칙이다.
- 책임, 즉 변경할 이유를 파악하려 애쓰다 보면 코드를 추상화하기도 쉬워진다. 더 좋은 추상화가 더 쉽게 떠오른다.

- SRP는 이해하고 지키기 수월한 개념이지만 SRP는 클래스 설계자가 가장 무시하는 규칙 중 하나다.
- SW를 돌아가게 만드는 활동과 깨끗하게 만드는 활동은 별개다. 우리 다수는 프로그램이 돌아가면 일이 끝났다고 여기고 깨끗하고 체계적인 소프트웨어라는 다음 관심사로 전환하지 않는다.
- 자잘한 클래스가 많아지면 큰그림을 이해가기 어렵다고 우려하지만, 작은 클래스 여러개든 큰 클래스 몇개든 돌아가는 부품은 수가 비슷하다.

- 강조. 작은 클래스 여럿으로 이뤄진 시스템이 더 바람직하다.
- 작은 클래스는 맡은 책임이 하나며, 변경할 이유가 하나며, 클래스들과 혐력해 시스템에 필요한 동작을 수행한다.

### 응집도

- 클래스는 인스턴스 변수 수가 작아야 한다.
- 각 클래스 매서드는 프로퍼티를 하나 이상 사용해야 한다.
- 일반적으로 메서드가 변수를 더 많이 사용할수록 메서드와 클래스는 응집도가 더 높다.
- 가장 응집도 높은건 모든 변수를 모든 메서드에서 사용

- 응집도가 가장 높은 클래스는 가능하지도 바람직하지도 않다. 하지만 우리는 응집도가 높은 클래스를 선호한다.
- 응집도가 높은건 메서드와 변수가 의존하며 논리적 단위로 묶이는것이다.

- 함수를 작게, 매개변수 목록을 짧게를 따르다보면 프로퍼티 변수가 아주 많아진다.
- 이는 새로운 클래스로 쪼개야 한다는 신호다.

#### 응집도를 유지하면 작은 클래스 여럿이 나온다

- 큰 함수를 작은 함수로 나누기만 해도 클래스 수가 많아진다.

1. 큰 함수를 쪼개려함
2. 작은 함수를 분리하려고 하는데 큰함수에 정의된 변수를 4개 씀
3. 작은 함수에 그 4개를 인수로 넣어야 할까? -> 프로퍼티로 변수를 사용하면 된다. 쪼개기 쉬워짐
4. 4개의 프로퍼티가 생김. 이건 방금 큰 함수 또는 작은 함수 한곳에서만 쓰던 프로퍼티임 -> 클래스의 응집도가 떨어짐 (응집도는 프로퍼티를 얼마나 많은 메서드에서 사용하는지니까)
5. 클래스가 응집도가 떨어진다면 작은 클래스로 쪼개면 된다.

## 변경하기 쉬운 클래스

- 대다수 시스템은 지속적인 변경이 가해진다. 변경할 때마다 시스템이 의도대로 동작하지 않을 위험이 있다.
- 깨끗한 시스템은 클래스를 정리해 변경의 위험을 낮춘다.

### 변경으로부터 격리

> 구현클래스에 의존하면 테스트 하기 어렵다. DIP로 구현하면(상위 클래스가 하위 구현클래스에 의존하는게 아닌 추상화, 인터페이스에 의존하기)테스트하기 쉽다.

- 요구사항은 변한다. 따라서 코드도 변한다.
- 객체지향 프로그래밍에는 구체적인 클래스와 추상 클래스가 있다
- 상세한 구현에 의존하는 클라이언트 클래스는 구현이 바뀔때 위험에 빠진다. 그래서 추상클래스를 사용해 영향을 격리해야한다.

- Portfolio라는 클래스의 메서드를 테스트 해본다고 생각해보자. 이 클래스가 외부 api를 직접 사용해 계산을 한다면, 테스트 하기 어렵다. 5분 마다 바뀌는 값에 항상 테스트 값이 일정하지 않을꺼다.

```java
public class Portfolio {
    private StockExchange exchange;

    public Portfolio(StockExchange exchange) {
        this.exchange = exchange;
    }
}

```

- 이번엔 외부 api 대신 우리가 만든 StockExchange 인터페이스를 사용하는걸로 해보자
- StockExchange 인터페이스를 실체화한 구현 클래스 무언가는 몰라도 된다. protfolio는 인터페이스를 참조만 하면된다.

- 이제 테스트를 위해 일정 값을 넣어둔 페이크값 클래스를 하나 만든다. 이건 StockExchange인터페이스의 구현체다.

```java
public class FixedStockExchangeStub implements StockExchange {
    private Map<String, Integer> fixedPrices = new HashMap<>();

    public void fix(String symbol, int price) {
        fixedPrices.put(symbol, price);
    }

    public Money currentPrice(String symbol) {
        return new Money(fixedPrices.get(symbol));
    }
}

```

- 아래 코드에서 Portfolio를 테스트할때 더이상 외부 api값에 변동될 일 없는 테스트를 해볼 수 있다.
- 값은 우리가 바꾼 페이크 값이지만, 포트폴리오의 참조에는 변경이 없다.

```java
@Before
protected void setup() {
    exchange = new FixedStockExchangeStub();
    exchange.fix("MSFT", 100); // 항상 100불
    portfolio = new Portfolio(exchange);
}

@Test
public void GivenFiveMSFTTotalShouldBe500() {
    portfolio.add(5, "MSFT");
    Assert.assertEquals(500, portfolio.value());
}

```

- 위 처럼 테스트가 가능할 정도로 결합도를 낮추면 유연성가 재사용성을 높일 수 있다.
- 결합도가 낮음 -> 격리가 잘 되어있음 -> 이해하기 쉬움

# 감상문

> 오늘 클래스 장을 나가면서 가장 감명깊게 배운점은, 하나의 큰 함수를 쪼개면서 작은 클래스까지 만들어가는 과정을 본것이다.
> 또한 단일책임원칙이라는 solid 처음 규칙을 모호하게 알던것에서 여러 예제를 통해 하나의 책임이 어떤 의미인지도 되새길 수 있었다.
> 응집도에 대한 클래스 내에서의 관점도 나에게 새로웠다
