# 10장 클래스

> 표현력과 이루어진 함수에 신경을 아무리 써도 더 차원 높은 단계까지 신경쓰지 않는다면 깨끗한 코드를 얻기 어렵다.

## 클래스 체계

클래스 정의시 가장 먼저 변수 목록이 나온다.

- 정적 static
- 공개 public
- 비공개 private

> 공개 변수가 필요한 경우는 거의 없다.

변수 목록 다음에는 공개 함수가 나온다. 비공개함수는 자신을 호출하는 공개함수 집후에 넣는다. 즉 추상화 단계가 순차적으로 내려간다. 그래서 프로그램은 신문 기사처럼 읽힌다.

> 이 부분에서 주목해서 본 내용은 신문기사처럼 읽힌다는 것 있었습니다.

이전 `함수`장에서도 마찬가지로

> 코드가 신문기사처럼 읽히게 하기 위해서 다른 함수 내부에서 사용되는 함수는 해당 함수 직전에 선언해야 한다던 내용이 있습니다.

저는 이 부분을 읽으면서 신문처럼 읽히는건 좋은데, 함수때나 지금이나 그렇고 뭔가 코드를 너무 강요하는 식이라는 느낌을 받았습니다. 물론 해당 방법이 안좋다 라는것은 아닙니다.

프론트에느에서는 styled-component 라는 스타일링용 라이브러리를 많이 사용합니다. 해당 style로 결국 컴포넌트의 일종 즉 함수로 분류됩니다. 여기서 언급한 내용처럼 신문처럼 위에서 아래로 읽혀야 하기 때문이라는 논리로 생각한다면, 이 styled-component도 사용하는 컴포넌트 위쪽에 선언해서 사용해야 합니다. 하지만 스타일코드는 기능에는 보통 상관없는 코드들로 이루어져있습니다. 그래서 저는 컴포넌트 하단으로 빼버리는 경우가 많습니다.

```jsx
const Container = styled.div`
  display: flex;
  justify-contents: center;
  font-weight: bold;
  color: #ff00ff;
`;

const MyComponent = () => {
  return (
    <Container>
      <h1>안녕하세요</h1>
      <span>이재진입니다</span>
    </Container>
  );
};
```

```jsx
const MyComponent = () => {
    return (
        <Container>
            <h1>안녕하세요</h1>
            <span>이재진입니다</span>
        </Container>
    )
}

const Container = styled.div`
    display: flex;
    justify-contents: center;
    font-weight: bold;
    color: #ff00ff;
```

그냥 이런 다양한 경우가 있기 때문에 너무 이게 무조건 맞다 이런게 아니라는걸 상기시키기 위해서 한 번 넣어봤습니다.

### 캡슐화

변수와 유틸리티 함수는 가능한 공개하지 않는편이 낫지만 반드시 숨겨야 하는 것도 아니다. 때로는 protected로 선언해 테스트 코드에서 접근을 허용하기도 한다.

> 사실 테스트도 잘 안하고, 클래스도 잘 사용하지 않습니다. 그래서 왜 클래스를 캡슐화 해야할까? 생각을 해봤습니다.

- 이전 `경계`장에서 언급한 내용인데, 클래스의 캡슐화를 통해서 권한을 통제해 안전하게 유지하라 라는 이야기를 했었습니다. 아마 그 이야기의 연장선이 아닐까 라는 생각을 했습니다.

종합적으로 캡슐화 했을 때는 다음과 같은 이점이 있습니다.

- 구조를 알지 못해서 기능을 사용하는데 무리가 없음
- 변경에 유연한 설계를 제공함
- 불변성을 보장해 안정성이 증가함
- 의도를 명확하게 전달이 가능함
- 책임의 범위를 제한시킬 수 있음

캡슐화의 단점도 좀 알아봤는데 다음과 같습니다.

- 테스트가 어렵다, 그래서 protected로 설정해 놓고 테스트를 하라고 이야기하고 있는 것 입니다.
- 너무 많은 캡슐화는 오히려 유연성을 줄일 수 있다.
- 복잡도 증가, 너무 많은 중간 계층으로 인해서 오히려 복잡해질 가능성이 있음
- 확장성 및 공유의 어려움, 필요한 정보를 너무 많이 숨기면 다른 개발자가 사용하거나 재사용하기 어려움

> 글쓴이는 이 내용에 대해서 다음과 같이 이야기 했습니다.

"정보는 숨기되, 유용한 인터페스로 잘 드러내야 한다" 완전히 숨기기 보다는 의도와 역할이 명확한 경계를 만드는게 중요하다고 이야기 합니다.

## 클래스는 작아야 한다!

함수는 물리적인 행 수로 크기를 측정했다면, 클래스는 맡은 책임의 수로 함수의 크기를 가늠한다.

클래스 이름은 해당 클래스의 책임을 기술해야 한다.

- 클래스 내부에서 하는 작업의 수가 너무 많음
- 클래스 이름이 모호하다 === 책임이 너무 많아서

if, and, of, but을 사용하지 않고 25단어 내외로 가능해야 한다.

> 이 부분을 읽고 너무 디테일하게 잡는거 아닌가? 라는 생각을 했습니다.

### 단일 책임 원칙

- 클래스나 모듈을 변경할 이유가 하나뿐이어야 한다는 원칙이다.

```java
public class SuperDashboard extends JFrame implements MetaDataUser {
 public Component getLastFocusedComponent()
 public void setLastFocused(Component lastFocused)
 public int getMajorVersionNumber()
 public int getMinorVersionNumber()
 public int getBuildNumber()
}
```

해당 클래스는 보기에는 작아보인다.
하지만 많은 책임을 가지고 있다.

- SuperDashboard는 소프트웨어 버전 정보를 추적한다.
- SuperDashboard는 자바 스윙 컴포넌트를 관리한다.
  - 스윙 컴포넌트가 바뀌면 버전 정보가 변경된다.

책임, 즉 변경할 이유를 파악하려 애쓰다 보면 코드를 추상화하기도 쉬워진다.

버전을 관리하기 위한 독립된 클래스를 만들 수 있다.

```java
public class Version {
 public int getMajorVersionNumber()
 public int getMinorVersionNumber()
 public int getBuildNumber()
}
```

하지만 대부분의 클래스 설계자는 SRP를 무시하는 경향이 있다.

소프트웨어를 돌아가게 만드는 활동과 소프트웨어를 깨끗하게 만드는 활동은 완전 별개다. 우리들 대다수는 깨끗하고 체계적인 소프트웨어 보다는 돌아가는 소프트웨어에 초점을 맞춘다.

문제는 우리들 대다수는 돌아가면 끝 이라고 여긴다.

하지만 규모가 어느 수준에 이르는 시스템에서는 체계적인 정리가 필수다.

> 단일 책임 원칙 이라는 단어를 어디서 들어봤을까 생각을 해봤는데, restful에 대해서 설명할 때 "단일 책임 원칙"을 많이 이야기 합니다. 그래서 찾아봤는데 두 "단일 책임 원칙"에는 맥락의 차이가 존재합니다.

#### RESTful 설계 vs. 단일 책임 원칙 (SRP)

| 항목               | 단일 책임 원칙 (SRP)                 | RESTful 설계                            |
| ------------------ | ------------------------------------ | --------------------------------------- |
| **적용 대상**      | 클래스, 함수, 모듈 등 소스 코드 레벨 | API, URI, HTTP 메서드 등 설계 레벨      |
| **책임 분리 기준** | 변경의 이유                          | 리소스와 행위의 조합                    |
| **주요 목적**      | 응집도 향상, 유지보수 용이성         | 일관된 인터페이스, 명확한 설계          |
| **실제 사례**      | `UserService`, `UserRepository`      | `GET /users`, `POST /users` 등 REST API |

- 이 둘의 차이점을 조금 쉽게 생각하자면
- SRP에서는 관심사로 분리된 단일책임 원칙을 이야기하는 것 이고,
- RESTful같은 경웨는 리소스의 행위에 초점을 두고 있습니다.

### 응집도

응집도가 높다는 것은, 클래스에 속한 메서드와 변수가 서로 의존하며 논리적인 단위로 묶인다는 의미이다.

함수를 작게, 매개변수 목록을 짧게 라는 전력을 따르다 보면, 몇몇 메서드만이 사용하는 인스턴스 변수가 아주 많아진다. 이는 새로운 클래스로 쪼개야 한다는 신호다.

응집도를 높아지도록 변수와 메서드를 적절히 분리해 새로운 클래스 두세 개로 쪼개준다.

> 저는 이 부분이 이해가 잘 안됐습니다.

"엥 위에서는 응집도가 높으면 안좋다 그랬는데, 왜 마지막에 응집도를 높이려면 이라는 표현을 쓴거지?"

알고 보니깐, 응집도가 높은건 논리적으로 잘 묶여있는것 이기 때문에 좋은 것 이지만, 과도하게 응집도가 높아지면, 즉 하나의 인스턴스 변수에 많은 메서드가 묶여버리면, 이전에 나왔던 "단일 책임 원칙"을 벗어날 수 있다는 의미라고 합니다.

여기서도 의문이 하나 더 들었습니다. 그럼 이 응집도라는게 어느정도가 적당하다는 걸까?

이 부분은 본인이 판단했을 때, 혹은 책에서 이야기한 것 처럼, 클래스의 이름에 대해서 모호해 지거나, 지나치게 많은 책임을 처리하고 있다면 의심을 해보고, 고민을 해볼 수 있는 정도라고 생각합니다.(결국 스스로 판단해야한다는 뜻 == 역량을 키워라)

### 응집도를 유지하면 작은 클래스 여럿이 나온다.

큰 함수를 작은 함수 여럿으로 나누기만 해도 클래스 수가 많아진다.

함수를 나눠도, 정의된 변수를 모두 사용하려면 함수에 인자를 많이 넘겨야 한다.

만약 이 변수들을 클래스 인스턴스 변수로 만든다면? 함수에는 인수가 필용없어 그만큼 함수를 쪼개기 쉬워진다.

하지만 이렇게 된다면, 클래스의 응집력을 잃는다. - 응집력을 결정하는 요소는 변수와 메서드 사이 관계이기 때문

그럼 클래스로 분리하면 되지 않는가? 그러면 응집력도 잃지 않으면서 독자적으로 관리할 수 있는 클래스가 된다.

커누스 교수의 프로그램을 예로 들어본다.

```
대충 main함수에 모든 인스턴스 변수와, 메서드로 이루어져 있음
```

리팩터링 후 다음과 같이 만들 수 있다.

```java
public class PrimePrinter {}  //main함수 포함해, 실행 환경을 책임짐
public class RowColumnPagePrinter {} // 출력하는 모양에 대한 정보를 담음
public class PrimeGenerator {} // 소수 목록을 생성 정보를 담음
```

각 클래스가 하나의 책임만 가지고 있다.

리팩터링을 통해서 결과적으론 코드의 길이가 길어졌다.
하지만 읽기 쉬워졌고, 각 클래스는 응집도가 높아졌다. 또한 수정과 확장이 쉬운 구조로 바뀌었다.

## 변경하기 쉬운 클래스

무언가를 변경할 때 마다 의도대로 동작하지 않을 위험이 따른다. 깨끗한 시스템은 클래스를 체계적으로 정리해 변경에 수반하는 위험을 낮춘다.

새로운 기능을 추가하거나, 기존의 기능을 변경하려고 해도, 단일 책임 원칙을 지키지 않고 있는 구조에서는 바꾸기가 쉽지 않다.

변경과, 추가를 위해서는 책임 분리를 해야한다.

여러개로 쪼개진 클래스는 단순하다. 코드를 이해하기 쉽다. 함수 하나를 수정해도, 다른 함수가 망가질 위험도 사라졌다.

- SRP만족
- OCP만족
  - 클래스는 확장에 개방적이고 수정에 폐쇄적이어야 한다는 원친인데, 파생클래스를 통해서 생성하기 때문 새 기능이 개방적인 동시에 다른 클래스를 닫아놓는 방식으로 수정에 폐쇄적이다.

### 변경으로부터 격리

요구사항은 항상 변한다.

구체적인 구현에 의존하는 코드는 이러한 변화에 취약하다.

> 그래서 우리는 인터페이스와 추상 클래스를 사용해 구현이 미치는 여향을 격리한다.

5분마다 달라니지는 API로 테스트 코드를 짜기는 어렵다.

```java
class Portfolio {
    TokyoStockExchange exchange = new TokyoStockExchange();
}
```

이 구조에선 TokyoStockExchange가 바뀌면 Portfolio도 수정해야 해서 테스트가 어렵다.

API를 직접호출하는 대신 새로운 인터페이스를 생성 후 메서드 하나를 선언한다.

```java
public interface StockExchange {
    Money currentPrice(String symbol);
}
```

그리고 stockExchange 인터페이스를 구현하는 TokyoStockExchange클래스를 구현한다. 그리고 Portfolio 생성자를 수정해 StockExchange 참조자를 인수로 받는다.

```java
class TokyoStockExchange implements StockExchange {
    public Money currentPrice(String symbol) {
        // 실제 외부 API 호출
    }
}
```

```java
class Portfolio {
    private StockExchange exchange;

    public Portfolio(StockExchange exchange) {
        this.exchange = exchange;
    }
}

```

Portfolio 클래스는 StockExchange라는 추상 인터페이스에만 의존한다.

실제 구현체는 나중에 넣어주기만 하면 된다. (의존성 주입)

```java
class FixedStockExchangeStub implements StockExchange {
    public Money currentPrice(String symbol) {
        return new Money(100); // 고정된 가격 반환
    }
}

```

테스트용 가짜 값을 넣어서 테스트가 가능하다.

이런테스트가 가능할 정도로 시스템 결합도를 낮추면 유연성과 재사용성도 더욱 높아진다.

결합도를 최소로 출이면서 자연스럽게 다른 클래스 설계 원칙인 `DIP`를 따르는 클래스가 나온다.

본질적으로 클래스가 상세한 구현이 아니라 추상화에 의존해야 한다는 원칙이다.

> 찾아보니깐 이 책의 저가가 `SOLID`원칙을 제안한 사람이라고 합니다.

- `SOLID`원칙은 객체지향 설계에서 유지보수성과 확장성을 높이기 위한 다섯 가지 핵심 원칙을 의미한다고 합니다.

### SOLID 원칙 요약

| 약어  | 원칙 이름                             | 설명                                                                                                              |
| ----- | ------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| **S** | Single Responsibility Principle (SRP) | 클래스는 **하나의 책임**만 가져야 한다.<br>변경 이유는 하나뿐이어야 한다.                                         |
| **O** | Open/Closed Principle (OCP)           | **확장에는 열려 있고, 수정에는 닫혀 있어야** 한다. 기존 코드를 건드리지 않고 새로운 기능을 추가할 수 있어야 한다. |
| **L** | Liskov Substitution Principle (LSP)   | **자식 클래스는 부모 클래스를 대체할 수 있어야** 한다. 다형성이 깨지지 않도록 설계해야 한다.                      |
| **I** | Interface Segregation Principle (ISP) | **사용하지 않는 인터페이스에 의존하면 안 된다.** 인터페이스는 작고 명확하게 분리해야 한다.                        |
| **D** | Dependency Inversion Principle (DIP)  | **상세 구현이 아니라 추상화에 의존**해야 한다. 고수준 모듈이 저수준 모듈에 의존하지 않아야 한다.                  |

위에서 언급된 모든 내용을 하나의 원칙으로 만든건데, 해당 원칙을 사용해서 소프트웨어 설계의 뼈대를 세우는 데 큰 도움이 된다고 합니다.

# 감상평

클래스를 잘 모르기도 하고, 이번 장을 읽으면서 느낀점은 이렇게까지 빡빡하게 해야하나? 라는 것 이었습니다. 마지막 부분에가서 class를 많이 만들어서 유지보수 하는 부분이 있는데, 해당 부분을 보면서 class로 나누면 좋구나 라는 느낌만 받았고, 한 편으로는 너무 많은 class는 오히려 혼란을 줄 수 있는거 아닌가? 라는 생각을 했습니다.
