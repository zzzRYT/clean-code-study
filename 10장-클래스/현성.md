# 10장 클래스

- 코드의 표현력과 그 코드로 이루어진 함수에 아무리 신경 쓸지라도 좀 더 차원 높은 단계까지 신경 쓰지 않으면 깨끗한 코드를 얻기는 어렵다.

## 클래스 체계

- 클래스를 정의하는 표준 자바 관례에 따르면, 가장 먼저 변수 목록이 나온다.
- 변수 선언 순서
  - 가장 먼저: static + public 상수
  - 다음: static + private 변수
  - 마지막: private 인스턴스 변수
  - public 변수는 거의 사용하지 않음 (캡슐화를 위해)
- 함수 선언 순서
  - 가장 먼저: public 메서드
  - 그다음: 각 public 메서드에서 사용하는 private 메서드들을 바로 아래에 위치시킴
  - 즉, 추상화 단계가 순차적으로 내려간다.
  - 결과적으로 프로그램(코드)이 신문기사처럼 읽힌다.

> 자바 클래스 정의의 표준 관례를 GPT를 이용하여 코드로 표현해봤습니다.

```java
package com.example;

import java.util.List;

public class User {
    // 상수
    public static final int MAX_AGE = 120;

    // static 변수
    private static int userCount = 0;

    // 인스턴스 변수
    private String name;
    private int age;

    // 생성자
    public User(String name, int age) {
        this.name = name;
        this.age = age;
        userCount++;
    }

    // public 메서드
    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    // private 메서드
    private boolean isAdult() {
        return age >= 18;
    }
}
```

> 너무 당연한 말이지만 먼저 패키지 및 import 문을 작성하고 클래스를 선언한 다음 상수를 정의하고 static 필드, 인스턴스 필드, 생성자, public 메서드, private 메서드 순으로 작성합니다.
> 추가적으로 자바스크립트 스타일 가이드도 찾아봤습니다. 공식적인 표준은 없지만 "Airbnb JavaScript Style Guide", "Google JavaScript Style Guide" 등의 가이드가 있었습니다.
> 요즘에는 Prettier와 ESLint를 사용하면 코드 스타일을 자동으로 관리할 수 있다 보니까 머리 꽁꽁 싸맬 필요가 없어서 편하다는 생각도 듭니다.

### 캡슐화

- 변수와 유틸리티 함수는 가능한 공개하지 않는 편이 낫지만 반드시 숨겨야 한다는 법칙도 없다.
- 때로는 변수나 유틸리티 함수를 protected로 선언해 테스트 코드에 접근을 허용하기도 한다.
- 캡슐화를 풀어주는 결정은 언제나 최후의 수단이다.

## 클래스는 작아야 한다!

- 클래스를 만들 때의 규칙
  - 첫 번째는 크기가 작아야 한다.
  - 두 번째도 크기가 작아야 한다.
- 클래스가 작아야 한다는 것은 얼마나 작아야 하는가?

너무 많은 책임

```java
public class SuperDashboard extends JFrame implements MetaDataUser {
  public String getCustomizerLanguagePath()
  public void setSystemConfigPath(String systemConfigPath)
  public String getSystemConfigDocument()
  public void setSystemConfigDocument(String systemConfigDocument)
  public boolean getGuruState()
  public boolean getNoviceState()
  public boolean getOpenSourceState()    public void showObject(MetaObject object)
  public void showProgress(String s)
  public boolean isMetadataDirty()
  public void setIsMetadataDirty(boolean isMetadataDirty)
  public Component getLastFocusedComponent()
  public void setLastFocused(Component lastFocused)
  public void setMouseSelectState(boolean isMouseSelected)
  public boolean isMouseSelected()
  public LanguageManager getLanguageManager()
  public Project getProject()
  public Project getFirstProject()
  public Project getLastProject()
  public String getNewProjectName()
  public void setComponentSizes(Dimension dim)
  public String getCurrentDir()
  public void setCurrentDir(String newDir)
  public void updateStatus(int dotPos, int markPos)
  public Class[] getDataBaseClasses()
  public MetadataFeeder getMetadataFeeder()
  public void addProject(Project project)
  public boolean setCurrentProject(Project project)
  public boolean removeProject(Project project)
  public MetaProjectHeader getProgramMetadata()
  public void resetDashboard()
  public Project loadProject(String fileName, String projectName)
  public void setCanSaveMetadata(boolean canSave)
  public MetaObject getSelectedObject()
  public void deselectObjects()
  public void setProject(Project project)
  public void editorAction(String actionName, ActionEvent event)
  public void setMode(int mode)
  public FileManager getFileManager()
  public void setFileManager(FileManager fileManager)
  public ConfigManager getConfigManager()
  public void setConfigManager(ConfigManager configManager)
  public ClassLoader getClassLoader()
  public void setClassLoader(ClassLoader classLoader)
  public Properties getProps()
  public String getUserHome()
  public String getBaseDir()
  public int getMajorVersionNumber()
  public int getMinorVersionNumber()
  public int getBuildNumber()
  public MetaObject pasting(
        MetaObject target, MetaObject pasted, MetaProject project)
  public void processMenuItems(MetaObject metaObject)
  public void processMenuSeparators(MetaObject metaObject)
  public void processTabPages(MetaObject metaObject)
  public void processPlacement(MetaObject metaObject)
  public void processCreateLayout(MetaObject object)
  public void updateDisplayLayer(MetaObject object, int layerIndex)
  public void propertyEditedRepaint(MetaObject object)
  public void processDeleteObject(MetaObject object)
  public boolean getAttachedToDesigner()
  public void processProjectChangedState(boolean hasProjectChanged)
  public void processObjectNameChanged(MetaObject object)
  public void runProject()
  public void setAllowDragging(boolean allowDragging)
  public boolean allowDragging()
  public boolean isCustomizing()
  public void setTitle(String title)
  public IdeMenuBar getIdeMenuBar()
  public void showHelper(MetaObject metaObject, String propertyName)
  // ... 많은 비공개 메서드가 이어진다 ...
}
```

- 대다수 개발자는 위 클래스가 엄청나게 크다는 사실에 동의하리라. SuperDashboard 클래스를 '만능 클래스'라 부르는 개발자가 있을지도 모르겠다.

충분히 작을까?

```java
public class SuperDashboard extends JFrame implements MetaDataUser {
  public Component getLastFocusedComponent()
  public void setLastFocused(Component lastFocused)
  public int getMajorVersionNumber()
  public int getMinorVersionNumber()
  public int getBuildNumber()
}
```

- SuperDashboard 클래스의 메서드 수를 작게 줄였지만 책임은 여전히 너무 많다
- 실제로 작명은 클래스 크기를 줄이는 첫 번째 관문이다.
- 클래스 이름이 모호하다면 필경 클래스 책임이 너무 많아서다. (ex. Processor, Manager, Super 등)
